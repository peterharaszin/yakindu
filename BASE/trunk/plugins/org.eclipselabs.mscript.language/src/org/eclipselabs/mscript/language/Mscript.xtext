/****************************************************************************
 * Copyright (c) 2010 Andreas Unger and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andreas Unger - initial API and implementation 
 ****************************************************************************/

grammar org.eclipselabs.mscript.language.Mscript
hidden(WS, ML_COMMENT, SL_COMMENT)

generate ast "http://www.eclipselabs.org/mscript/AST/1.0.0"

import 'http://www.eclipse.org/emf/2002/Ecore' as ecore

Mscript :
	(namespaces+=NamespaceDefinition)*;
	
NamespaceDefinition :
	'namespace' name=QualifiedName '{'
		(members+=NamespaceMember)*
	'}';

NamespaceMember :
	NamespaceDefinition |
	TypeDefinition;
	
TypeDefinition :
	DataTypeDefinition |
	FunctionDefinition;

/*
 * DataTypeDefinition
 */
 
DataTypeDefinition :
	EnumerationDefinition |
	RecordDefinition |
	TypeAliasDefinition;

/*
 * Enumeration
 */
 	
EnumerationDefinition :
	'enum' name=ID '{'
		(literalDeclarations+=EnumerationLiteralDeclaration (',' literalDeclarations+=EnumerationLiteralDeclaration)*)?
	'}';
	
EnumerationLiteralDeclaration :
	name=ID;
	
/*
 * TypeAlias
 */
 
TypeAliasDefinition :
	'type' name=ID '=' type=PrimitiveTypeSpecifier ';';	

/*
 * Record
 */

RecordDefinition :
	'record' name=ID '{'
		(fieldDeclarations+=RecordFieldDeclaration)*
	'}'; 

RecordFieldDeclaration :
	name=ID ':' type=DataTypeSpecifier ';';

/*
 * Function
 */
 
FunctionDefinition :
	(stateful?='stateful')? 'func' name=ID
			('<' templateParameterDeclarations+=ParameterDeclaration (',' templateParameterDeclarations+=ParameterDeclaration)* '>')?
			'(' (inputParameterDeclarations+=ParameterDeclaration (',' inputParameterDeclarations+=ParameterDeclaration)*)? ')'
			'->' outputParameterDeclarations+=ParameterDeclaration (',' outputParameterDeclarations+=ParameterDeclaration)* '{'
		(assertionDeclarations+=AssertionDeclaration |
		functorDeclarations+=FunctorDeclaration |
		stateVariableDeclarations+=StateVariableDeclaration |
		equations+=EquationDefinition)*
	'}';

ParameterDeclaration :
	name=ID;

enum AssertionStatusKind :
	Info='info' |
	Warning='warning' |
	Error='error' |
	Fatal='fatal';

AssertionDeclaration :
	(static?='static')? 'assert' predicate=Expression ':' statusKind=AssertionStatusKind message=Expression ';';

StateVariableDeclaration :
	'var' name=ID ';';
	
FunctorDeclaration :
	'functor' name=ID ':' functionName=QualifiedName ('<' templateArgumentDeclarations+=ArgumentDeclaration (',' templateArgumentDeclarations+=ArgumentDeclaration)* '>')? ';';

ArgumentDeclaration :
	name=ID;

EquationDefinition :
	leftHandSide=Expression '=' rightHandSide=Expression ';';

/*
 * Data type specifier
 */

DataTypeSpecifier :
	PrimitiveTypeSpecifier | NamedTypeSpecifier;
	
PrimitiveTypeSpecifier :
	NumericTypeSpecifier | BooleanTypeSpecifier | StringTypeSpecifier;
	
NumericTypeSpecifier :
	RealTypeSpecifier | IntegerTypeSpecifier | ComplexTypeSpecifier | GaussianTypeSpecifier;
	
RealTypeSpecifier :
	{RealTypeSpecifier} 'real' ('(' unit=UnitExpression ')')? ('[' dimensions+=ArrayDimensionSpecification (',' dimensions+=ArrayDimensionSpecification)* ']')?;
	
IntegerTypeSpecifier :
	{IntegerTypeSpecifier} 'int' ('(' unit=UnitExpression ')')? ('[' dimensions+=ArrayDimensionSpecification (',' dimensions+=ArrayDimensionSpecification)* ']')?;
	
ComplexTypeSpecifier :
	{ComplexTypeSpecifier} 'complex' ('(' unit=UnitExpression ')')? ('[' dimensions+=ArrayDimensionSpecification (',' dimensions+=ArrayDimensionSpecification)* ']')?;

GaussianTypeSpecifier :
	{GaussianTypeSpecifier} 'gauss' ('(' unit=UnitExpression ')')? ('[' dimensions+=ArrayDimensionSpecification (',' dimensions+=ArrayDimensionSpecification)* ']')?;

BooleanTypeSpecifier :
	{BooleanTypeSpecifier} 'bool' ('[' dimensions+=ArrayDimensionSpecification (',' dimensions+=ArrayDimensionSpecification)* ']')?;
	
StringTypeSpecifier :
	{StringTypeSpecifier} 'string' ('[' dimensions+=ArrayDimensionSpecification (',' dimensions+=ArrayDimensionSpecification)* ']')?;
	
NamedTypeSpecifier :
	typeReference=QualifiedName ('[' dimensions+=ArrayDimensionSpecification (',' dimensions+=ArrayDimensionSpecification)* ']')?;
	
ArrayDimensionSpecification :
	{ArrayDimensionSpecification} (size=Expression)?;
	
/*
 * Expressions
 */

Expression :
	LetExpression | IfExpression | SwitchExpression | RangeExpression;

LetExpression :
	'let' variables+=LetExpressionVariable (',' variables+=LetExpressionVariable)* 'in' targetExpression=Expression;
	
LetExpressionVariable :
	name=ID '=' assignedExpression=Expression;
	
IfExpression :
	'if' condition=Expression 'then' thenExpression=Expression 'else' elseExpression=Expression;

SwitchExpression :
	'switch' controlExpression=Expression
		(cases+=SwitchCase)*
		'default' ':' defaultExpression=Expression;

SwitchCase :
	'case' caseExpression=ImpliesExpression ':' resultExpression=Expression;

RangeExpression returns Expression :
	ImpliesExpression ({RangeExpression.operands+=current} ':' operands+=ImpliesExpression (':' operands+=ImpliesExpression)?)?;

ImpliesExpression returns Expression :
	LogicalOrExpression ({ImpliesExpression.leftOperand=current} '=>' rightOperand=LogicalOrExpression)?;

LogicalOrExpression returns Expression :
	LogicalAndExpression ({LogicalOrExpression.operands+=current} ('||' operands+=LogicalAndExpression)+)?;
	
LogicalAndExpression returns Expression :
	EqualityExpression ({LogicalAndExpression.operands+=current} ('&&' operands+=EqualityExpression)+)?;

EqualityExpression returns Expression :
	RelationalExpression ({EqualityExpression.leftOperand=current} operator=EqualityOperator rightOperand=RelationalExpression)?;

enum EqualityOperator :
	EqualTo='==' |
	NotEqualTo='!=';
	
RelationalExpression returns Expression :
	AdditiveExpression ({RelationalExpression.leftOperand=current} (typeTest?='is' type=DataTypeSpecifier | operator=RelationalOperator rightOperand=AdditiveExpression))?;

enum RelationalOperator :
	LessThan='<' |
	LessThanOrEqualTo='<=' |
	GreaterThan='>' |
	GreaterThanOrEqualTo='>=';

AdditiveExpression returns Expression :
	MultiplicativeExpression ({AdditiveExpression.leftOperand=current} (rightParts+=AdditiveExpressionPart)+)?;

AdditiveExpressionPart :
	operator=AdditiveOperator operand=MultiplicativeExpression;

enum AdditiveOperator :
	Addition='+' |
	Subtraction='-';

MultiplicativeExpression returns Expression :
	PowerExpression ({MultiplicativeExpression.leftOperand=current} (rightParts+=MultiplicativeExpressionPart)+)?;

MultiplicativeExpressionPart :
	operator=MultiplicativeOperator operand=PowerExpression;
	
enum MultiplicativeOperator :
	Multiplication='*' |
	Division='/' |
	ElementWiseMultiplication='.*' |
	ElementWiseDivision='./';
	
PowerExpression returns Expression :
	UnaryExpression ({PowerExpression.operand=current} operator=PowerOperator exponent=UnaryExpression)?;

enum PowerOperator :
	Power='^' |
	ElementWisePower='.^';
	
UnaryExpression returns Expression :
	PostfixExpression | {UnaryExpression} operator=UnaryOperator operand=PostfixExpression;
	
enum UnaryOperator :
	Minus='-' |
	LogicalNot='!';
	
PostfixExpression returns Expression :
	PrimaryExpression ({PostfixExpression.operand=current} operator=PostfixOperator)?;

enum PostfixOperator :
	Transpose="'";

PrimaryExpression returns Expression :
	Literal |
	FeatureCall |
	UnitConstructionOperator |
	BeginExpression |
	EndExpression;

CallablePrimaryExpression returns Expression :
	ArrayConstructionOperator |
	ArrayConcatenationOperator |
	ParenthesizedExpression;

Literal :
	NumericLiteral | BooleanLiteral | StringLiteral;
	
NumericLiteral :
	RealLiteral | IntegerLiteral;
	
RealLiteral :
	value=REAL (modifier=ID)? ('(' unit=UnitExpression ')')?;
	
IntegerLiteral :
	value=INTEGER (modifier=ID)? ('(' unit=UnitExpression ')')?;

BooleanLiteral :
	value=BooleanKind;

enum BooleanKind :
	False='false' | True='true';
	
StringLiteral :
	value=STRING;
		
FeatureCall returns Expression :
	CallablePrimaryExpression ({FeatureCall.target=current} (parts+=FeatureCallPart)+)? | {FeatureCall} target=SimpleName (parts+=FeatureCallPart)*;

SimpleName returns Expression :
	{SimpleName} identifier=ID;

FeatureCallPart :
	FeatureReference | ArrayElementReference | OperationCall | IterationCall;
	
FeatureReference :
	'.' name=(ID | 'unit');
	
ArrayElementReference :
	'[' subscripts+=Subscript (',' subscripts+=Subscript)* ']';

OperationCall :
	{OperationCall} '(' (arguments+=Expression (',' arguments+=Expression)*)? ')';

IterationCall :
	{IterationCall} '(' variables+=IterationVariable (',' variables+=IterationVariable)* (';' accumulator=IterationAccumulator)? '|' expression=Expression ')';

IterationVariable :
	name=ID;

IterationAccumulator :
	name=ID '=' initializer=Expression;
	
Subscript :
	slice?=':' | expression=Expression;

ArrayConstructionOperator :
	'{' expressions+=Expression ((',' expressions+=Expression)* | 'for' iterationClauses+=ArrayConstructionIterationClause (',' iterationClauses+=ArrayConstructionIterationClause)*) '}';

ArrayConstructionIterationClause :
	variableName=ID 'in' collectionExpression=Expression;

ArrayConcatenationOperator :
	'[' rows+=ExpressionList (';' rows+=ExpressionList)* ']';
	
ExpressionList :
	expressions+=Expression (',' expressions+=Expression)*;
	
UnitConstructionOperator :
	'unit' '(' unit=UnitExpression ')';

ParenthesizedExpression :
	'(' expressions+=Expression (',' expressions+=Expression)* ')';

BeginExpression :
	{BeginExpression} 'begin';

EndExpression :
	{EndExpression} 'end';
	
QualifiedName :
	identifiers+=ID ('.' identifiers+=ID)*;

/*
 * Unit expressions
 */
	
UnitExpression :
	{UnitExpression} (numerator=UnitExpressionNumerator ('/' denominator=UnitExpressionDenominator)?)?;

UnitExpressionNumerator :
	one=INTEGER /* must be '1' */ | factors+=UnitExpressionFactor ('*' factors+=UnitExpressionFactor)*;

UnitExpressionDenominator :
	factors+=UnitExpressionFactor | '(' factors+=UnitExpressionFactor ('*' factors+=UnitExpressionFactor)* ')';

UnitExpressionFactor :
	operand=ID ('^' exponent=UnitExpressionExponent)?;

UnitExpressionExponent :
	(negative?='-')? value=INTEGER;

/*
 * Terminals
 */
 
terminal ID :
	('_' | 'a'..'z' | 'A'..'Z') ('0'..'9' | '_' | 'a'..'z' | 'A'..'Z')*;

terminal STRING : 
	'"' (!('\\' | '"') | '\\' ("'" | '"' | '?' | '\\' | 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v'))* '"';

terminal REAL returns ecore::EDouble :
	('0'..'9')+ '.' ('0'..'9')* (('e' | 'E') ('+'|'-')? ('0'..'9')+)?;

terminal INTEGER returns ecore::ELong :
	('0'..'9')+;

terminal ML_COMMENT :
	'/*' -> '*/';

terminal SL_COMMENT :
	'//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS :
	(' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER :
	.;
