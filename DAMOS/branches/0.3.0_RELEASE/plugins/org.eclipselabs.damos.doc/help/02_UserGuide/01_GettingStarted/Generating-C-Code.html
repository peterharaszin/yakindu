<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Getting Started - Generating C Code</title><link type="text/css" rel="stylesheet" href="../content/PLUGINS_ROOT/PRODUCT_PLUGIN/book.css"/><link type="text/css" rel="stylesheet" href="../../style.css"/></head><body><table class="navigation" style="width: 100%;" border="0" summary="navigation"><tr><th style="width: 100%" align="center" colspan="3">Generating C Code</th></tr><tr><td style="width: 20%" align="left"><a href="GettingStarted.html" title="Creating and Simulating a Damos Model"><img alt="Previous" border="0" src="images/prev.gif"/></a></td><td style="width: 60%" align="center"></td><td style="width: 20%" align="right"><a href="Structuring-Models-using-Subsystems.html" title="Structuring Models using Subsystems"><img alt="Next" border="0" src="images/next.gif"/></a></td></tr><tr><td style="width: 20%" align="left" valign="top">Creating and Simulating a Damos Model</td><td style="width: 60%" align="center"></td><td style="width: 20%" align="right" valign="top">Structuring Models using Subsystems</td></tr></table><hr/><h1 id="GeneratingCCode">Generating C Code</h1><p>In this topic you will learn how to generate C code from a Damos model and how to integrate the generated C code in existing applications. We assume that you read the previous topic and know how to create a basic Damos model.</p><h2 id="ExampleModel">Example Model</h2><p>The example model will be a simple PI controller-based cruise control with an anti-windup circuit. The inputs of the controller will be the desired speed and the actual speed. The output value (i.e. engine power) will be limited to a value between 0.0 and 1.0 (0% to 100%). The anti-windup circuit is needed to prevent the integrator to windup when the maximum output power is reached.</p><p>To create the example model:</p><ol><li>Create a new block diagram in the model folder of a new Damos project (see previous topic for more details):<ul><li>Create a new Damos project (<strong>File &gt; New &gt; Project...</strong> and then select <strong>Damos &gt; Damos Project</strong>).</li><li>Create a model folder in the new Damos project.</li><li>Create a new block diagram in the model folder (right-click on the model folder <strong>File &gt; New &gt; Other...</strong> and then select <strong>Damos &gt; Block Diagram</strong>).</li></ul></li><li>From the <strong>General</strong> palette drawer, add two <strong>Inport</strong> blocks and one <strong>Outport</strong> block to the block diagram.</li><li>Red markers will indicate that the data types are missing. To fix this, specify <strong>real</strong> as data type for all Inports and Outports using the Properties view. Alternatively, you can use the quick fix from the tool tip of the error marker.</li><li>Name the two Inports <em>DesiredSpeed</em> and <em>ActualSpeed</em>, and the Outport <em>Power</em>.</li><li>Optionally, for each Inport and Outport select <strong>Show Name</strong> in the <strong>Appearance</strong> property tab to show their names.</li></ol><p>The block diagram should look as follows:</p><p><img alt="Initial block diagram" title="Initial block diagram" border="0" src="02_GeneratingCode_images/InitialBlockDiagram.png"/></p><p>You may ask, why do we need these Inports and Outports? As we will see later, those blocks will represent the interface of our system in the generated code.</p><p>Next, we add the following block to the block diagram:</p><ul><li>2 <strong>Sum</strong> blocks</li><li><strong>Gain</strong> block with a gain value of <code>0.1</code></li><li><strong>Constant</strong> block with a value of <code>0</code></li><li><strong>Switch</strong> block</li><li><strong>Discrete Integrator</strong> block with an initial value of 0 and a gain value of <code>0.075(1/s)</code></li><li><strong>Saturate</strong> block with upper limit of <code>1</code> and lower limit of <code>0</code></li><li><strong>Compare</strong> block with an equals (<code>==</code>) operator</li></ul><p>After connecting the blocks, the block diagram should look as follows: </p><p><img alt="Final block diagram" title="Final block diagram" border="0" src="02_GeneratingCode_images/FinalBlockDiagram.png"/></p><p><em>Important:</em> Before we can generate code from the model, we must specify the sample time for model:</p><ol><li>Select the leftmost <strong>Sum</strong> block.</li><li>In the <strong>General</strong> tab of the Properties view, set the <strong>Timing Constraint</strong> property to <em>Synchronous</em>.</li><li>Enter <code>0.1(s)</code> into the <strong>Sample Time (second)</strong> field.</li></ol><p>The other blocks will automatically inherit the timing constraint from the Sum block. If you forget to set this property, you will get an error stating that the sample time could not be resolved for certain blocks when invoking the code generator or simulator.</p><h2 id="CreatingGeneratorConfiguration">Creating Generator Configuration</h2><p>To generate code from a Damos model, we need to create a <em>generator configuration</em>. To create the generator configuration:</p><ol><li>Right-click the block diagram in the project explorer, and then <strong>New &gt; Other...</strong>.</li><li>Select <strong>Damos &gt; C Code Generator Configuration</strong>: <img alt="New C code generator configuration wizard" title="New C code generator configuration wizard" border="0" src="02_GeneratingCode_images/NewCCodeGeneratorConfiguration.png"/></li><li>Keep the default name <em>GenerateCruiseControl</em> and click <strong>Finish</strong>.</li></ol><p>After clicking <strong>Finish</strong>, the new generator configuration file with the extension <em>.dconfig</em> will be opened in a text editor. It should have the following contents:</p><pre><code>package cruisecontrol

import damos.codegen.*
import damos.codegen.c.*

configuration GenerateCruiseControl {

	select generator DefaultGenerator {
		projectName = "CruiseControl"
		sourceFolder = "src-gen"
		systemSourceFile = "CruiseControl.c"
	}

	system CruiseControl {
		prefix = "CruiseControl_"
		//propagate computation {
		//	map real() to float64
		//	map int() to int32
		//}
	}

}
</code></pre><p>The <code>projectName</code> and <code>sourceFolder</code> properties specify the target project and source folder, respectively. If you want to generate the code into another project or folder, you can change those properties accordingly.</p><h2 id="GeneratingSourceCode">Generating Source Code</h2><p>To start the code generation process, right-click on the generator configuration file (in our example <em>GenerateCruiseControl.dconfig</em>) and select <strong>Generate Code</strong>. The target source folder should now contain a C header file (.h) and a C source file (.c).</p><h2 id="IntegratingtheGeneratedCodeinExistingApplications">Integrating the Generated Code in Existing Applications</h2><p>The public interface of the generated code is defined in the header file. It consists of two functions:</p><ul><li><code>CruiseControl_initialize(void)</code> function, which must be called only once, and the</li><li><code>CruiseControl_execute(const CruiseControl_Input *input, CruiseControl_Output *output)</code> function, which must be invoked periodically.</li></ul><p>The <code>input</code> and <code>output</code> parameters of the <em>execute</em> function are pointers to structures containing a member variable for each Inport and Output, respectively. Before invoking the <em>execute</em> function, the member variables of the input structure must be set (e.g. from sensor data). After returning from the <em>execute</em> function, the results can be read from the member variables of the output structure for further processing (e.g. new actuator value).</p><p>A simplified application may look as follows:</p><pre><code>void cruiseControlTask(void) {
	CruiseControl_Input input;
	CruiseControl_Output output;
	
	CruiseControl_initialize();
	
	for (;;) {
		input.desiredSpeed = getDesiredSpeed();
		input.actualSpeed = getActualSpeed();
		
		CruiseControl_execute(&amp;input, &amp;output);
		
		setEnginePower(output.power);
	}
}
</code></pre><p><em>Note:</em> Damos allows you to provide <em>target generators</em> for specific systems. In this case you do not need to write the glue code for accessing the hardware. See the topic <em>Concepts</em> for more information on target generators.</p><hr/><table class="navigation" style="width: 100%;" border="0" summary="navigation"><tr><td style="width: 20%" align="left"><a href="GettingStarted.html" title="Creating and Simulating a Damos Model"><img alt="Previous" border="0" src="images/prev.gif"/></a></td><td style="width: 60%" align="center"><a href="GettingStarted.html" title="Getting Started"><img alt="Getting Started" border="0" src="images/home.gif"/></a></td><td style="width: 20%" align="right"><a href="Structuring-Models-using-Subsystems.html" title="Structuring Models using Subsystems"><img alt="Next" border="0" src="images/next.gif"/></a></td></tr><tr><td style="width: 20%" align="left" valign="top">Creating and Simulating a Damos Model</td><td style="width: 60%" align="center"></td><td style="width: 20%" align="right" valign="top">Structuring Models using Subsystems</td></tr></table></body></html>