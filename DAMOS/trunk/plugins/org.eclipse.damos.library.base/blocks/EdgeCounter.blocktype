package damos.blocks

blockType EdgeCounter {

	input up
	input down
	output y

	parameter initialValue = 0
	parameter step = 1
	parameter upperLimit = 10
	parameter lowerLimit = 0
	parameter upTrigger = 0 predefined {
		0 alias "Rising",
		1 alias "Falling"
	}
	parameter downTrigger = 0 predefined {
		0 alias "Rising",
		1 alias "Falling"
	}

	behavior {
		check(boolean, boolean, <0>, <1>, <10>, <0>, <0>, <0>) -> int
		check(boolean, boolean, <0>, <1>, <10>, <0>, <1>, <1>) -> int
		
		static assert initialValue is real(?) :
			error "Initial value must be numeric"
			
		static assert step is real(?) :
			error "Step value must be numeric"
	
		static assert upperLimit is real(?) :
			error "Upper limit value must be numeric"
			
		static assert lowerLimit is real(?) :
			error "Lower limit value must be numeric"
	
		static assert initialValue is real(?) && step is real(?) => unit(initialValue) == unit(step) :
			error "Initial value and step value must have same unit"
			
		static assert initialValue is real(?) && upperLimit is real(?) => unit(initialValue) == unit(upperLimit) :
			error "Initial value and upper limit value must have same unit"
	
		static assert initialValue is real(?) && lowerLimit is real(?) => unit(initialValue) == unit(lowerLimit) :
			error "Initial value and lower limit value must have same unit"
	
		static assert up is boolean:
			error "Up input value must be boolean"
	
		static assert down is boolean:
			error "Down input value must be boolean"
	
		static assert upTrigger is int:
			error "Up trigger value must be integer"
	
		static assert downTrigger is int:
			error "Down trigger value must be integer"
	
		static assert upperLimit is real(?) && lowerLimit is real(?) && unit(upperLimit) == unit(lowerLimit) => upperLimit >= lowerLimit :
			warning "Upper limit value should be greater than or equal to lower limit value"
	
		eq up{-1} = upTrigger != 0
		eq down{-1} = downTrigger != 0
		
		eq y{-1} = initialValue
		eq y{n} =
			if static if upTrigger == 0 then !up{n-1} && up else up{n-1} && !up then
				let result = y{n-1} + step in
					if result < upperLimit then
						result
					else
						upperLimit
			else if static if downTrigger == 0 then !down{n-1} && down else down{n-1} && !down then
				let result = y{n-1} - step in
					if result > lowerLimit then
						result
					else
						lowerLimit
			else
				y{n-1}
	}

}
