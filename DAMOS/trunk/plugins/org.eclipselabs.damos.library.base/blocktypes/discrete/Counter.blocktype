asynchronous blockType damos.library.base._discrete.Counter

socket input up {
	directFeedthrough never
}
socket input down {
	directFeedthrough never
}
output y

parameter initialValue = 0
parameter step = 1
parameter upperLimit = 10
parameter lowerLimit = 0
parameter upTrigger = 0 predefined {
	0 as "Rising",
	1 as "Falling",
	2 as "Both"
}
parameter downTrigger = 0 predefined {
	0 as "Rising",
	1 as "Falling",
	2 as "Both"
}

behavior {

	stateful func main<initialValue, step, upperLimit, lowerLimit, upTrigger, downTrigger>(triggerKind, up, down) -> y {
		check<0, 1, 10, 0, 0, 0>(int, bool, bool) -> int
		check<0, 1, 10, 0, 1, 1>(int, bool, bool) -> int
		check<0, 1, 10, 0, 2, 2>(int, bool, bool) -> int
		
		static assert initialValue is real() :
			error "Initial value must be numeric"
			
		static assert step is real() :
			error "Step value must be numeric"
	
		static assert upperLimit is real() :
			error "Upper limit value must be numeric"
			
		static assert lowerLimit is real() :
			error "Lower limit value must be numeric"
	
		static assert initialValue is real() && step is real() => unit(initialValue) == unit(step) :
			error "Initial value and step value must have same unit"
			
		static assert initialValue is real() && upperLimit is real() => unit(initialValue) == unit(upperLimit) :
			error "Initial value and upper limit value must have same unit"
	
		static assert initialValue is real() && lowerLimit is real() => unit(initialValue) == unit(lowerLimit) :
			error "Initial value and lower limit value must have same unit"
	
		static assert up is bool:
			error "Up input value must be boolean"
	
		static assert down is bool:
			error "Down input value must be boolean"
	
		static assert upTrigger is int:
			error "Up trigger value must be integer"
	
		static assert downTrigger is int:
			error "Down trigger value must be integer"
	
		static assert upperLimit is real() && lowerLimit is real() && unit(upperLimit) == unit(lowerLimit) => upperLimit >= lowerLimit :
			warning "Upper limit value should be greater than or equal to lower limit value"
	
		eq y{-1} = initialValue
		eq y{n} =
			if triggerKind == 0 then
				if static if upTrigger == 0 then up else static if upTrigger == 1 then !up else true then
					let result = y{n-1} + step in
						if result < upperLimit then
							result
						else
							upperLimit
				else
					y{n-1}
			else
				if static if downTrigger == 0 then down else static if downTrigger == 1 then !down else true then
					let result = y{n-1} - step in
						if result > lowerLimit then
							result
						else
							lowerLimit
				else
					y{n-1}
	}
	
}
