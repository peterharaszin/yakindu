package damos.library.base._discrete

asynchronous blockType Counter {

	socket input up {
		directFeedthrough never
	}
	socket input down {
		directFeedthrough never
	}
	output y
	
	parameter initialValue = 0
	parameter step = 1
	parameter upperLimit = 10
	parameter lowerLimit = 0
	parameter upTrigger = 0 predefined {
		0 alias "Rising",
		1 alias "Falling",
		2 alias "Both"
	}
	parameter downTrigger = 0 predefined {
		0 alias "Rising",
		1 alias "Falling",
		2 alias "Both"
	}
	
	type Message = union { boolean up, down }

	stateful function main(const initialValue, const step, const upperLimit, const lowerLimit, const upTrigger, const downTrigger, message) -> y {
		check(Message, <0>, <1>, <10>, <0>, <0>, <0>) -> int
		check(Message, <0>, <1>, <10>, <0>, <1>, <1>) -> int
		check(Message, <0>, <1>, <10>, <0>, <2>, <2>) -> int
		
		static assert initialValue is real(?) :
			error "Initial value must be numeric"
			
		static assert step is real(?) :
			error "Step value must be numeric"
	
		static assert upperLimit is real(?) :
			error "Upper limit value must be numeric"
			
		static assert lowerLimit is real(?) :
			error "Lower limit value must be numeric"
	
		static assert initialValue is real(?) && step is real(?) => unit(initialValue) == unit(step) :
			error "Initial value and step value must have same unit"
			
		static assert initialValue is real(?) && upperLimit is real(?) => unit(initialValue) == unit(upperLimit) :
			error "Initial value and upper limit value must have same unit"
	
		static assert initialValue is real(?) && lowerLimit is real(?) => unit(initialValue) == unit(lowerLimit) :
			error "Initial value and lower limit value must have same unit"
	
		static assert message is Message:
			error "Up and down inputs must be boolean"
	
		static assert upTrigger is int:
			error "Up trigger value must be integer"
	
		static assert downTrigger is int:
			error "Down trigger value must be integer"
	
		static assert upperLimit is real(?) && lowerLimit is real(?) && unit(upperLimit) == unit(lowerLimit) => upperLimit >= lowerLimit :
			warning "Upper limit value should be greater than or equal to lower limit value"
	
		eq y{-1} = initialValue
		eq y{n} =
			inspect message
			when up:
				if static if upTrigger == 0 then up else static if upTrigger == 1 then !up else true then
					let result = y{n-1} + step in
						if result < upperLimit then
							result
						else
							upperLimit
				else
					y{n-1}
			when down:
				if static if downTrigger == 0 then down else static if downTrigger == 1 then !down else true then
					let result = y{n-1} - step in
						if result > lowerLimit then
							result
						else
							lowerLimit
				else
					y{n-1}
	}
	
}
