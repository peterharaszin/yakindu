package damos.library.base._discrete

synchronous blockType DiscreteIntegrator {

	input u {
		directFeedthrough never
	}
	output y
	
	parameter gain = 1(1/s) // normalize
	parameter initialCondition = 0
	parameter accumulate = false predefined {
		true alias "yes",
		false alias "no"
	}

	stateful function main(const gain, const initialCondition, const accumulate, const Ts, u) -> y {
		check(real(kg), <1>, <0(kg*s)>, <false>, <1(s)>) -> real(kg*s)
		check(real, <1>, <0(s)>, <false>, <1(s)>) -> real(s)
		check(real, <1(1/s)>, <0>, <false>, <1(s)>) -> real
		// accumulate checks
		check(real(kg), <1>, <0(kg)>, <true>, <1(s)>) -> real(kg)
		check(real, <1>, <0>, <true>, <1(s)>) -> real
		check(real, <1>, <0>, <true>, <1(s)>) -> real
	
		static assert u is real(?) :
			error "Input value must be numeric"
	
		static assert initialCondition is real(?) :
			error "Initial value must be numeric"
			
		static assert !accumulate && initialCondition is real(?) && u is real(?) && gain is real(?) => unit(initialCondition) == unit(gain) * unit(u) * unit{s} :
			error "Initial condition unit must be input value unit times gain unit times second"
			
		static assert accumulate && initialCondition is real(?) && u is real(?) && gain is real(?) => unit(initialCondition) == unit(gain) * unit(u) :
			error "Initial condition unit must be input value unit times gain unit"

		static assert gain is real(?) :
			error "Gain value must be numeric"
			
		static assert accumulate is boolean :
			error "Accumulate value must be boolean"

		var sum
	
		eq sum{0} = initialCondition
		eq sum{n+1} =
			static if accumulate then
				sum{n} + gain * u{n}
			else
				sum{n} + gain * Ts * u{n}
		eq y{n} = sum{n}
	}
	
}
