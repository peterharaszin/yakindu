/****************************************************************************
 * Copyright (c) 2010 Andreas Unger and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andreas Unger - initial API and implementation 
 ****************************************************************************/

grammar org.eclipselabs.damos.mscript.Mscript
hidden(WS, ML_COMMENT, SL_COMMENT)

import 'http://www.eclipse.org/emf/2002/Ecore' as ecore
import "platform:/resource/org.eclipselabs.damos.mscript/model/Mscript.ecore"

Module:
	'package' packageName=QualifiedName
	(importDeclarations+=ImportDeclaration)*
	(declarations+=Declaration)*;
	
ImportDeclaration:
	'import' importedNamespace=QualifiedNameWithWildcard;

Declaration:
	DataTypeDeclaration |
	FunctionDeclaration;

/*
 * DataTypeDeclaration
 */
 
DataTypeDeclaration:
	EnumerationDeclaration |
	StructDeclaration |
	TypedefDeclaration;

/*
 * Enumeration
 */
 	
EnumerationDeclaration:
	'enum' name=ValidID '{'
		(literalDeclarations+=EnumerationLiteralDeclaration (',' literalDeclarations+=EnumerationLiteralDeclaration)*)?
	'}';
	
EnumerationLiteralDeclaration:
	name=ValidID;
	
/*
 * Typedef
 */
 
TypedefDeclaration:
	'typedef' typeSpecifier=DataTypeSpecifier name=ValidID;	

/*
 * Struct
 */

StructDeclaration:
	'struct' name=ValidID '{'
		members+=StructMember (',' members+=StructMember)*
	'}'; 

/*
 * Function
 */
 
FunctionDeclaration:
	(kind=FunctionKind)? 'function' name=ValidID
			('<' templateParameterDeclarations+=TemplateParameterDeclaration (',' templateParameterDeclarations+=TemplateParameterDeclaration)* '>')?
			'(' (inputParameterDeclarations+=InputParameterDeclaration (',' inputParameterDeclarations+=InputParameterDeclaration)*)? ')'
			'->' outputParameterDeclarations+=OutputParameterDeclaration (',' outputParameterDeclarations+=OutputParameterDeclaration)* '{'
		(checks+=Check |
		assertions+=Assertion |
		functionObjectDeclarations+=FunctionObjectDeclaration |
		stateVariableDeclarations+=StateVariableDeclaration |
		constantDeclarations+=ConstantDeclaration |
		equations+=Equation)*
	'}';

enum FunctionKind:
	Stateful='stateful' | Continuous='continuous';
	
TemplateParameterDeclaration:
	name=ValidID;

InputParameterDeclaration:
	name=ValidID;

OutputParameterDeclaration:
	name=ValidID;

Check:
	'check'
			('<' templateArguments+=Expression (',' templateArguments+=Expression)* '>')?
			'(' (inputParameterTypes+=DataTypeSpecifier (',' inputParameterTypes+=DataTypeSpecifier)*)? ')'
			'->' outputParameterTypes+=DataTypeSpecifier (',' outputParameterTypes+=DataTypeSpecifier)*;

enum AssertionStatusKind:
	Info='info' |
	Warning='warning' |
	Error='error' |
	Fatal='fatal';

Assertion:
	(static?='static')? 'assert' condition=Expression ':' statusKind=AssertionStatusKind message=Expression;

StateVariableDeclaration:
	'var' name=ValidID;

ConstantDeclaration:
	'const' name=ValidID '=' initializer=Expression;

FunctionObjectDeclaration:
	'fob' functionName=[FunctionDeclaration|QualifiedName] ('<' templateArguments+=Expression (',' templateArguments+=Expression)* '>')? name=ValidID;

Equation:
	(initial?='initial')? 'eq' leftHandSide=Expression '=' rightHandSide=Expression;

/*
 * Data type specifier
 */

DataTypeSpecifier:
	definedType=(PrimitiveType | ArrayType | StructType) | type=[DataType|QualifiedName];

PrimitiveType:
	NumericType | BooleanType | StringType;
	
NumericType:
	RealType | IntegerType | ComplexType | GaussianType;
	
RealType:
	{RealType} 'real' unit=Unit;
	
IntegerType:
	{IntegerType} 'int' unit=Unit;
	
ComplexType:
	{ComplexType} 'complex' unit=Unit;

GaussianType:
	{GaussianType} 'gaussian' unit=Unit;

BooleanType:
	{BooleanType} 'boolean';
	
StringType:
	{StringType} 'string';
	
ArrayType:
	TensorType | =>(definedElementType=(BooleanType | StringType) | elementType=[DataType]) '[' dimensions+=ArrayDimension (',' dimensions+=ArrayDimension)* ']';
	
TensorType:
	definedElementType=NumericType '[' dimensions+=ArrayDimension (',' dimensions+=ArrayDimension)* ']';
	
ArrayDimension:
	{ArrayDimension} (size=Expression)?;

StructType:
	'struct' '{'
		members+=StructMember (',' members+=StructMember)*
	'}'; 

StructMember:
	typeSpecifier=DataTypeSpecifier name=ValidID;

/*
 * Expressions
 */

Expression:
	LetExpression | IfExpression | SwitchExpression | RangeExpression;

LetExpression:
	'let' assignments+=LetExpressionAssignment (',' assignments+=LetExpressionAssignment)* 'in' target=Expression;
	
LetExpressionAssignment:
	(variables+=LetExpressionVariableDeclaration | '(' variables+=LetExpressionVariableDeclaration (',' variables+=LetExpressionVariableDeclaration)+ ')') '=' assignedExpression=Expression;

LetExpressionVariableDeclaration:
	name=ValidID;
	
IfExpression:
	(static?='static')? 'if' condition=Expression 'then' thenExpression=Expression 'else' elseExpression=Expression;

SwitchExpression:
	(static?='static')? 'switch' controlExpression=Expression
		(cases+=SwitchCase)*
		'default' ':' defaultExpression=Expression;

SwitchCase:
	'case' caseExpression=ImpliesExpression ':' resultExpression=Expression;

RangeExpression returns Expression:
	ImpliesExpression ({RangeExpression.operands+=current} ':' operands+=ImpliesExpression (':' operands+=ImpliesExpression)?)?;

ImpliesExpression returns Expression:
	LogicalOrExpression ({ImpliesExpression.leftOperand=current} '=>' rightOperand=LogicalOrExpression)?;

LogicalOrExpression returns Expression:
	LogicalAndExpression ({LogicalOrExpression.leftOperand=current} '||' rightOperand=LogicalAndExpression)*;
	
LogicalAndExpression returns Expression:
	EqualityExpression ({LogicalAndExpression.leftOperand=current} '&&' rightOperand=EqualityExpression)*;

EqualityExpression returns Expression:
	RelationalExpression ({EqualityExpression.leftOperand=current} operator=EqualityOperator rightOperand=RelationalExpression)*;

enum EqualityOperator:
	EqualTo='==' |
	NotEqualTo='!=';
	
RelationalExpression returns Expression:
	AdditiveExpression =>({RelationalExpression.leftOperand=current} operator=RelationalOperator rightOperand=AdditiveExpression | {TypeTestExpression.expression=current} 'is' typeSpecifier=DataTypeSpecifier)?;

enum RelationalOperator:
	LessThan='<' |
	LessThanOrEqualTo='<=' |
	GreaterThan='>' |
	GreaterThanOrEqualTo='>=';

AdditiveExpression returns Expression:
	MultiplicativeExpression ({AdditiveExpression.leftOperand=current} operator=AdditiveOperator rightOperand=MultiplicativeExpression)*;

enum AdditiveOperator:
	Add='+' |
	Subtract='-';

MultiplicativeExpression returns Expression:
	PowerExpression ({MultiplicativeExpression.leftOperand=current} operator=MultiplicativeOperator rightOperand=PowerExpression)*;

enum MultiplicativeOperator:
	Multiply='*' |
	Divide='/' |
	ElementWiseMultiply='.*' |
	ElementWiseDivide='./' |
	Modulo='%';
	
PowerExpression returns Expression:
	UnaryExpression ({PowerExpression.operand=current} operator=PowerOperator exponent=UnaryExpression)?;

enum PowerOperator:
	Power='^' |
	ElementWisePower='.^';
	
UnaryExpression returns Expression:
	PostfixExpression | {UnaryExpression} operator=UnaryOperator operand=PostfixExpression;
	
enum UnaryOperator:
	Negate='-' |
	LogicalNot='!';
	
PostfixExpression returns Expression:
	(QualifiedFeatureCall | MemberFeatureCall) ({PostfixExpression.operand=current} operator=PostfixOperator)?;

enum PostfixOperator:
	Derivative="'";

MemberFeatureCall returns Expression:
	PrimaryExpression (({ArrayElementAccess.array=current} '[' subscripts+=ArraySubscript (',' subscripts+=ArraySubscript)* ']')
		| ({MemberVariableAccess.target=current} '.' memberVariable=ValidID)
		| ({FunctionCall.arguments+=current} '.' feature=[CallableElement|ValidID] '(' (arguments+=Expression (',' arguments+=Expression)*)? ')')
		| ({IterationCall.target=current} '.' identifier=ValidID '(' iterationVariables+=IterationVariableDeclaration (',' iterationVariables+=IterationVariableDeclaration)* (';' accumulator=IterationAccumulator)? (';' breakCondition=Expression)? '|' expression=Expression ')'))*;

AssignableMemberFeatureCall returns Expression:
	AssignablePrimaryExpression (({ArrayElementAccess.array=current} '[' subscripts+=ArraySubscript (',' subscripts+=ArraySubscript)* ']') | ({MemberVariableAccess.target=current} '.' memberVariable=ValidID))*;

IterationAccumulator:
	name=ValidID '=' initializer=Expression;

IterationVariableDeclaration:
	name=ValidID;

ArraySubscript:
	slice?=':' | expression=Expression;

PrimaryExpression returns Expression:
	Literal |
	FeatureCall |
	UnitConstructionOperator |
	ArrayConstructionOperator |
	ArrayConcatenationOperator |
	StructConstructionOperator |
	ParenthesizedExpression |
	EndExpression |
	AlgorithmExpression;

AssignablePrimaryExpression returns Expression:
	VariableReference |
	ParenthesizedExpression;

Literal:
	NumericLiteral | BooleanLiteral | StringLiteral;
	
NumericLiteral:
	IntegerLiteral | RealLiteral;
	
RealLiteral:
	data=RealData unit=Unit;
	
RealData returns RealData hidden():
	ValidInt (('.' ValidInt (IJ | EXPIJ | (E ('+' | '-') ValidInt IJ?))?) | (EXPIJ | (E ('+' | '-') ValidInt IJ?)));

IntegerLiteral:
	data=IntegerData unit=Unit;

IntegerData returns IntegerData hidden():
	ValidInt IJ?;

BooleanLiteral:
	{BooleanLiteral} (true?='true' | 'false');

StringLiteral:
	value=STRING;
		
FeatureCall returns Expression:
	VariableReference | FunctionCall;
	
VariableReference returns Expression:
	{VariableReference} feature=[CallableElement|ValidID] ('{' stepExpression=StepExpression '}')?;

FunctionCall returns Expression:
	{FunctionCall} feature=[CallableElement|ValidID] '(' (arguments+=Expression (',' arguments+=Expression)*)? ')';

QualifiedFeatureCall returns Expression:
	QualifiedVariableReference | QualifiedFunctionCall;

QualifiedVariableReference returns Expression:
	{VariableReference} '::' feature=[CallableElement|QualifiedName];

QualifiedFunctionCall returns Expression:
	{FunctionCall} '::' feature=[CallableElement|QualifiedName] '(' (arguments+=Expression (',' arguments+=Expression)*)? ')';

StepExpression:
	RangeStepExpression;
	
RangeStepExpression returns StepExpression:
	AdditiveStepExpression ({RangeStepExpression.start=current} '..' end=AdditiveStepExpression)?;

AdditiveStepExpression returns StepExpression:
	NegateStepExpression ({AdditiveStepExpression.leftOperand=current} operator=AdditiveOperator rightOperand=NegateStepExpression)*;

NegateStepExpression returns StepExpression:
	PrimitiveStepExpression | {NegateStepExpression} '-' operand=PrimitiveStepExpression;

PrimitiveStepExpression returns StepExpression:
	StepLiteral | StepN;

StepLiteral:
	value=ValidInt;
	
StepN:
	{StepN} N;

ArrayConstructionOperator:
	'{' expressions+=Expression ((',' expressions+=Expression)* | 'for' iterationClauses+=ArrayConstructionIterationClause (',' iterationClauses+=ArrayConstructionIterationClause)*) '}';

ArrayConstructionIterationClause:
	variableName=ValidID 'in' collectionExpression=Expression;

ArrayConcatenationOperator:
	'[' rows+=ExpressionList (';' rows+=ExpressionList)* ']';
	
ExpressionList:
	expressions+=Expression (',' expressions+=Expression)*;
	
StructConstructionOperator:
	'{' members+=StructConstructionMember (',' members+=StructConstructionMember)* '}';
	
StructConstructionMember:
	name=ValidID '=' value=Expression;
	
UnitConstructionOperator:
	'unitlit' unit=ExplicitUnit;

ParenthesizedExpression:
	'(' expressions+=Expression (',' expressions+=Expression)* ')';

EndExpression:
	{EndExpression} 'end';
	
AlgorithmExpression returns Expression:
	{AlgorithmExpression} 'algorithm' body=Compound;

Compound:
	{Compound} '{' (statements+=Statement)* '}';

Statement:
	Compound |
	Assignment |
	LocalVariableDeclaration |
	IfStatement |
	WhileStatement |
	DoWhileStatement |
	ForStatement |
	ContinueStatement |
	BreakStatement |
	ReturnStatement;
	
Assignment:
	target=AssignableMemberFeatureCall '=' assignedExpression=Expression ';';
	
LocalVariableDeclaration:
	'var' name=ValidID '=' initializer=Expression ';';

IfStatement:
	'if' '(' condition=Expression ')' thenStatement=Statement (=>'else' elseStatement=Statement)?;
	
WhileStatement:
	'while' '(' condition=Expression ')' body=Statement;

ForStatement:
	'for' '(' iterationVariable=IterationVariableDeclaration 'in' collectionExpression=Expression ')' body=Statement;

DoWhileStatement:
	'do' body=Statement 'while' '(' condition=Expression ')' ';';

ContinueStatement:
	{ContinueStatement} 'continue' ';';

BreakStatement:
	{BreakStatement} 'break' ';';

ReturnStatement:
	'return' expression=Expression ';';

/*
 * Unit expressions
 */
	
Unit:
	{Unit} ('(' ')' | '(' numerator=UnitNumerator ('/' denominator=UnitDenominator)? ')' | numerator=ImplicitUnitNumerator);

ExplicitUnit returns Unit:
	'(' numerator=UnitNumerator ('/' denominator=UnitDenominator)? ')';

UnitNumerator:
	{UnitNumerator} ONE | factors+=UnitFactor ('*' factors+=UnitFactor)*;
	
ImplicitUnitNumerator returns UnitNumerator:
	{UnitNumerator};

UnitDenominator:
	factors+=UnitFactor | '(' factors+=UnitFactor ('*' factors+=UnitFactor)* ')';

UnitFactor:
	symbol=ValidID ('^' exponent=UnitExponent)?;

UnitExponent returns ecore::EInt:
	('-')? ValidInt;

QualifiedName:
	ValidID ('.' ValidID)*;

QualifiedNameWithWildcard:
	QualifiedName ('.*' | '.' '*')?;

ValidInt returns ecore::EInt:
	ONE | INT;

ValidID:
	N | IJ | E | EXPIJ | ID;
	
/*
 * Terminals
 */
 
terminal N:
	'n';

terminal IJ:
	'i' | 'j';
	
terminal E:
	'e' | 'E';

terminal EXP:
	E ('0'..'9')+;

terminal EXPIJ:
	EXP IJ;
	
terminal ONE:
	'1';

terminal INT:
	('0'..'9')+;

terminal ID:
	'_'? ('a'..'z' | 'A'..'Z') ('0'..'9' | '_' | 'a'..'z' | 'A'..'Z')*;

terminal STRING: 
	'"' (!('\\' | '"') | '\\' ("'" | '"' | '?' | '\\' | 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v'))* '"';

terminal ML_COMMENT:
	'/*' -> '*/';

terminal SL_COMMENT:
	'//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS:
	(' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER:
	.;
