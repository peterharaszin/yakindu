/*
 * generated by Xtext
 */
package org.yakindu.sct.model.stext.scoping;

import java.util.List;

import org.eclipse.emf.common.notify.Notifier;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.yakindu.base.base.NamedElement;
import org.yakindu.sct.model.sgraph.Scope;
import org.yakindu.sct.model.sgraph.Statechart;
import org.yakindu.sct.model.stext.stext.Expression;
import org.yakindu.sct.model.stext.stext.FeatureCall;
import org.yakindu.sct.model.stext.stext.InterfaceScope;
import org.yakindu.sct.model.stext.stext.InternalScope;
import org.yakindu.sct.model.stext.stext.TypedElementReferenceExpression;

import com.google.common.collect.Lists;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on
 * how and when to use it
 * 
 */
public class STextScopeProvider extends AbstractDeclarativeScopeProvider {

	
	public IScope scope_RegularEventSpec_event(EObject context, EReference reference){
		IScope scope = getDelegate().getScope(context, reference);
		System.out.println(scope);
		return scope;
	}
	
	public IScope scope_TypedElementReferenceExpression_reference(
			final EObject context, EReference reference) {
		List<EObject> scopeCandidates = getScopeCandidates(context);
		return Scopes.scopeFor(scopeCandidates);
	}

	protected List<EObject> getScopeCandidates(final EObject context) {
		List<EObject> scopeCandidates = Lists.newArrayList();
		Statechart statechart = getStatechart(context);
		EList<Scope> scopes = statechart.getScopes();
		for (Scope scope : scopes) {
			if (scope instanceof InterfaceScope) {
				String name = ((InterfaceScope) scope).getName();
				if (name == null || name.trim().length() == 0) {
					scopeCandidates.addAll(scope.getDeclarations());
				} else {
					scopeCandidates.add(scope);
				}
			} else if (scope instanceof InternalScope) {
				scopeCandidates.addAll(scope.getDeclarations());
			}
		}
		return scopeCandidates;
	}

	private Statechart getStatechart(EObject object) {
		ResourceSet resourceSet = object.eResource().getResourceSet();
		TreeIterator<Notifier> iter = resourceSet.getAllContents();
		while (iter.hasNext()) {
			Notifier next = iter.next();
			if (next instanceof Statechart)
				return (Statechart) next;
		}
		return null;
	}

	public IScope scope_FeatureCall_feature(final FeatureCall context,
			EReference reference) {
		Expression owner = context.getOwner();
		if(owner instanceof TypedElementReferenceExpression){
			NamedElement element = ((TypedElementReferenceExpression) owner).getReference();
			if(element instanceof Scope){
				IScope scope =  Scopes.scopeFor(((Scope) element).getDeclarations());
				return scope;
			}
		}
		return getDelegate().getScope(context, reference);

	}
}