/*
 * generated by Xtext
 */
package org.yakindu.sct.model.stext.scoping;

import java.util.List;

import org.eclipse.emf.common.notify.Notifier;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.yakindu.base.base.NamedElement;
import org.yakindu.sct.model.sgraph.Scope;
import org.yakindu.sct.model.sgraph.Statechart;
import org.yakindu.sct.model.stext.stext.Expression;
import org.yakindu.sct.model.stext.stext.FeatureCall;
import org.yakindu.sct.model.stext.stext.InterfaceScope;
import org.yakindu.sct.model.stext.stext.InternalScope;
import org.yakindu.sct.model.stext.stext.TypedElementReferenceExpression;

import com.google.common.collect.Lists;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on
 * how and when to use it
 * 
 */
public class STextScopeProvider extends AbstractDeclarativeScopeProvider {

	@Override
	public IScope getScope(EObject context, EReference reference) {
		String methodName = "scope_"
				+ reference.getEContainingClass().getName() + "_"
				+ reference.getName();
		System.out.println(methodName);
		// System.out.println(context);
		return super.getScope(context, reference);
	}

	public IScope scope_TypedElementReferenceExpression_reference(
			final EObject context, EReference reference) {
		System.out.println("Context! " + context);
		List<EObject> scopeCandidates = Lists.newArrayList();
		Statechart statechart = getStatechart(context);
		EList<Scope> scopes = statechart.getScopes();
		for (Scope scope : scopes) {
			if (scope instanceof InterfaceScope) {
				String name = ((InterfaceScope) scope).getName();
				if (name == null || name.trim().length() == 0) {
					scopeCandidates.addAll(scope.getEvents());
					scopeCandidates.addAll(scope.getVariables());
				} else {
					scopeCandidates.add(scope);
				}
			} else if (scope instanceof InternalScope) {
				scopeCandidates.addAll(scope.getEvents());
				scopeCandidates.addAll(scope.getVariables());
			}
		}
		return Scopes.scopeFor(scopeCandidates);
	}

	private Statechart getStatechart(EObject object) {
		ResourceSet resourceSet = object.eResource().getResourceSet();
		TreeIterator<Notifier> iter = resourceSet.getAllContents();
		while (iter.hasNext()) {
			Notifier next = iter.next();
			if (next instanceof Statechart)
				return (Statechart) next;
		}
		return null;
	}

	public IScope scope_FeatureCall_feature(final EObject context,
			EReference reference) {
		Expression owner = (Expression)((FeatureCall) context).getOwner();
		if(owner instanceof TypedElementReferenceExpression){
			NamedElement element = ((TypedElementReferenceExpression) owner).getReference();
			if(element instanceof Scope){
				IScope scope =  Scopes.scopeFor(((Scope) element).getDeclarations());
				return scope;
			}
		}
		return getDelegate().getScope(context, reference);

	}
	

	// public IScope scope_FeatureReferenceExpression_feature(
	// final FeatureReferenceExpression featureRef, EReference reference) {
	// IScope parentScope = getDelegate().getScope(featureRef, reference);
	// //Type context = featureRef.getContext();
	// // if(context != null){
	// // IScope featureScope = Scopes.scopeFor(context.getFeatures());
	// // System.out.println(featureScope);
	// // return new SimpleScope(parentScope, featureScope.getAllElements());
	// // }
	// return parentScope;
	// }

	/**
	 * public IScope scope_PropertyReference_context(final ExpressionRule
	 * context, EReference reference) { return new
	 * FilteringScope(getDelegate().getScope(context, reference), new
	 * Predicate<IEObjectDescription>() {
	 * 
	 * @Override public boolean apply(IEObjectDescription input) { // EObject
	 *           eObject = input.getEObjectOrProxy(); return
	 *           EcoreUtil2.isAssignableFrom( ApplicationModelPackage.eINSTANCE
	 *           .getCallEvent(), input.getEClass()); } }); }
	 * 
	 *           public IScope scope_EnumerationValue_enumerationLiteral(final
	 *           EnumerationValue context, EReference reference) { return
	 *           Scopes.scopeFor(((EnumerationType) context.getType())
	 *           .getLiterals()); }
	 * 
	 *           public IScope scope_PropertyReference_property( final
	 *           ExpressionRule context, EReference reference) { // infer from
	 *           user data return new
	 *           FilteringScope(getDelegate().getScope(context, reference), new
	 *           Predicate<IEObjectDescription>() {
	 * @Override public boolean apply(IEObjectDescription input) { String
	 *           containerClass = input
	 *           .getUserData(ExpressionsResourceDescription.E_CONTAINER_CLASS);
	 *           return MessageCommunicationEvent.class.getSimpleName()
	 *           .equals(containerClass); } }); }
	 * 
	 *           public IScope scope_PropertyReference_property( final
	 *           PropertyReference context, EReference reference) { if
	 *           (context.getContext() instanceof CallEvent) { CallEvent event =
	 *           (CallEvent) context.getContext(); List<Property>
	 *           visibleProperties = new ArrayList<Property>();
	 *           visibleProperties.addAll(event.getInputParameterVariable());
	 *           visibleProperties.addAll(event.getReturnParameterVariable());
	 *           return Scopes.scopeFor(visibleProperties); } else if
	 *           (context.getContext() == null) { // delegate to first rule,
	 *           where context is of no importance return
	 *           scope_PropertyReference_property( EcoreUtil2
	 *           .getContainerOfType(context, ExpressionRule.class), reference);
	 *           } return IScope.NULLSCOPE; }
	 * 
	 *           public IScope
	 *           scope_PropertyQualifier_property(PropertyQualifier context,
	 *           EReference reference) { if (context.getOwner() == null) { //
	 *           first after PropertyReference PropertyReference
	 *           containingReference = EcoreUtil2 .getContainerOfType(context,
	 *           PropertyReference.class); return
	 *           getScopeForProperty(containingReference.getProperty()); }
	 *           return getScopeForProperty(context.getOwner().getProperty()); }
	 * 
	 *           public IScope
	 *           scope_PropertyQualifier_property(PropertyReference context,
	 *           EReference reference) { Property property =
	 *           context.getProperty(); return getScopeForProperty(property); }
	 * 
	 *           private IScope getScopeForProperty(Property property) { Type
	 *           type = property.getType(); if (type instanceof ComplexType) {
	 *           return Scopes.scopeFor(((ComplexType) type).getElement()); }
	 *           return IScope.NULLSCOPE; }
	 */
}
