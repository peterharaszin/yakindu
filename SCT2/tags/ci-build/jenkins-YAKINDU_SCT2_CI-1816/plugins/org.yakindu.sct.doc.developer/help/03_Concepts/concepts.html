<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<title>concepts</title>
		<link type="text/css" rel="stylesheet" href="../style.css"/>
	</head>
	<body>
		<p><link href="../../../css/bootstrap.css" rel="stylesheet" />
			<br/><link href="../../../css/custom.css" rel="stylesheet" />
		</p>
		<h1 id="DeveloperConcepts">Developer Concepts</h1>
		<h2 id="APIspecificationsofthegeneratedcode">API specifications of the generated code</h2>
		<p>In the following comments the TrafficLight example statemachine is used to describe the API specifications of the code generated by the Yakindu C and Java code generators. The following image shows the statechart. It is a model of a simple pedestrian crossing with a traffic light for pedestrians and a traffic light for the cars.</p>
		<p>
			<img border="0" src="images/TrafficLight.png"/> 
		</p>
		<p>For Java you can checkout the project &#8218;org.yakindusct.examples.trafficlight&#8217; from the Yakindu google code repository ( 
			<a href="http://svn.codespot.com/a/eclipselabs.org/yakindu/SCT2/trunk/examples">Google code link</a> ). The Java example contains the statechart, sgen model, graphical widgets and some glue code to connect the generated code with the widgets. The graphical widgets are based on SWT. To execute the Java example you can run the file &#8218;CrossingDemoCycleBased.java&#8217; as &#8218;Java Application&#8217; from the eclipse &#8218;Run As&#8217; context menu.
		</p>
		<p>For C you can checkout the project &#8218;org.yakindu.examples.c.trafficlight&#8217; from the Yakindu google code repository ( 
			<a href="http://svn.codespot.com/a/eclipselabs.org/yakindu/SCT2/trunk/examples">Google code link</a> ). The C example contains the statechart, sgen model, graphical widgets and some glue code to connect the generated code with the widgets. The graphical widgets are based on Qt. To execute the c example you can run the file org_yakindu_sct_examples_c_trafficlight as &#8218;Local C/C++ application&#8217; from the eclipse &#8218;Run As&#8217; context menu.
		</p>
		<h3 id="SpecificationsofJavacode">Specifications of Java code</h3>
		<p>You find the generated code in the &#8218;src-gen&#8217; folder of the traffic light example.</p>
		<p>In the package &#8218;org.yakindu.sct.examples.trafficlight.cyclebased&#8217; are the most basic statemachine interfaces and classes located. These are needed by each statemachine and are independend from the concrete statemachine design.</p>
		<p>The interface 
			<code>IStatemachine</code> is implemented by each generated statemachine:
		</p>
		<pre><code>package org.yakindu.sct.examples.trafficlight.cyclebased;

/**
 * Basic interface for statemachines.
 * 
 * 
 */
public interface IStatemachine {

	/**
	* Initializes the statemachine. Use to init internal variables etc.
	*/
	public void init();

	/**
	* Enters the statemachine. Sets the statemachine in a defined state.
	*/
	public void enter();

	/**
	* Exits the statemachine. Leaves the statemachine with a defined state.
	*/
	public void exit();

	/**
	* Start a run-to-completion cycle.
	*/
	public void runCycle();
}
</code></pre>
		<p>It contains the four methods 
			<code>init()</code>, 
			<code>enter()</code>, 
			<code>exit()</code> and 
			<code>runCycle()</code>. The 
			<code>init()</code> method is used to initialize the internal objects of the statemachine after instantiation. Variables are initialized to a default value. If you have initialized variables in the statechart definition these initializations are done in the init method too. The 
			<code>enter()</code> method should be called if the statemachine is entered. It sets the statemachine into a defined state. The 
			<code>exit()</code> method is used to leave a statemachine statefully. If for example a history state is used in one of the top regions the last active state is stored and the statemachine is leaved via 
			<code>exit()</code> and reentered via 
			<code>enter()</code> it continues working with this state. The 
			<code>runCycle()</code> method is used to trigger a run to completion step in which the statemachine evaluates arising events and computes possible state changes.
		</p>
		<p>In the traffic light example timing is used (after clauses). To support this the interfaces &#8218;ITimedStatemachine&#8217;, &#8218;ITimerService&#8217; and the class &#8218;TimeEvent&#8217; are generated.</p>
		<pre><code>package org.yakindu.sct.examples.trafficlight.cyclebased;

/**
* Interface for state machines which use timed event triggers.
*/
public interface ITimedStatemachine {

	/**
	* Set the {@link ITimerService} for the state machine. It must be set
	* externally on a timed state machine before a run cycle can be correct
	* executed.
	* 
	* @param timerService
	*/
	public void setTimerService(ITimerService timerService);

	/**
	* Returns the currently used timer service.
	* 
	* @return {@link ITimerService}
	*/
	public ITimerService getTimerService();

	/**
	* Callback method if a {@link TimeEvent} occurred.
	* 
	* @param timeEvent
	*/
	public void onTimeEventRaised(TimeEvent timeEvent);
}
</code></pre>
		<p>
			<code>ITimedStatemachine</code> extends the generated statemachine to set a 
			<code>ITimerService</code> and provides a callback method 
			<code>onTimeEventRaised(TimeEvent timeEvent)</code> to raise 
			<code>TimeEvents</code>.
		</p>
		<h3 id="SpecificationsofCcode">Specifications of C code</h3>
	</body>
</html>