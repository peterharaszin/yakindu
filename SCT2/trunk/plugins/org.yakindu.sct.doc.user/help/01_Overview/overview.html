<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><body><h1 id="Overview">Overview</h1><h2 id="WhataretheYAKINDUStatechartTools2">What are the YAKINDU Statechart Tools 2</h2><p>The statechart tools are one central part of YAKINDU: the modular toolkit for model driven development of embedded systems. It is based on the open source development platform Eclipse. The YAKINDU Statechart tools provide the following tools to deal with state machine diagramms:</p><ul><li><strong>YAKINDU SCT editor</strong> to create and edit state charts</li><li><strong>YAKINDU simulator</strong> to simulate the behavior of state charts</li><li><strong>YAKINDU Xpand generator projects</strong> to create a transformation of the state chart in Xpand</li><li><strong>YAKINDU Xtend/Java generator projects</strong> to create a transformation in Xtend/Java</li><li>integrated validation</li></ul><p>The following graph shows these features and their relation to each other:</p><p><img border="0" src="images/overview_yakindu.jpg"/> </p><h3 id="Modeling">Modeling</h3><p>Yakindu Statechart Models are based on statecharts as defined by David<br/>Harel and are close to UML state machines. Thus, they support all<br/>structural model elements as defined by the UML specification, which are<br/>States (orthogonal and hierarchical), Regions, Transitions and Pseudo<br/>States (History, Deep History, Initial, Final, Choice, Join / Fork).<br/>In addition, Yakindu Statechart Models specify interfaces that define<br/>the interaction of the state machine with its environment. Besides some<br/>more advanced concepts like Entry / Exit Points, an interface basically<br/>consists of in and out Events as well as Variables including types.<br/>These well-defined statechart interfaces are especially useful in the<br/>context of component models and product line engineering.<br/>For defining interfaces and modeling the dynamic aspects of statecharts<br/>(triggers, guards and actions) SCT provides a statically typed, textual<br/>action language called <strong>SText</strong>. It tightly integrates into the graphical<br/>editor and supports the user with code completion, syntax highlighting,<br/>cross referencing and validation during modeling.</p><h3 id="Simulation">Simulation</h3><p>Yakindu Statechart Models can be executed via an integrated simulation<br/>engine. The simulation engine supports two different types of execution<br/>semantics, cycle based and event driven execution. The default execution<br/>semantic is cycle based which executes a statechart cycle within a fixed<br/>period of time and thus allows processing of concurrent events. In<br/>contrast, the event based approach executes a statechart cycle as soon<br/>as an event occurred.<br/>During simulation, the currently active states and the transition path<br/>including the previous states are highlighted in the editor for visual debugging. An additional view<br/>shows the variable values and allows to raise events.<br/>Apart from that, the engine uses a virtual time during simulation. The<br/>user can provide a time scaling factor that is multiplied with the real<br/>time. This is especially useful during debugging, if the statechart<br/>model contains very tight or long running time triggers.</p><h3 id="CodeGeneration">Code Generation</h3><p>Yakindu Statechart Tools currently support the generation of Java, C and<br/>C++ Code.  All generators can be customized with a generator model. This<br/>is a textual model file where generator features, like the execution<br/>type (event or cycle based), or the interface styles (static or<br/>generic), can be specified.<br/>The code generation process can either be executed with a builder that<br/>starts code generation on resource change or manually with a context<br/>menu action.</p><h3 id="Domainspecificadaptability">Domain specific adaptability</h3><p>Yakindu Statechart Tools were developed with a domain specific<br/>adaptability in mind. Several extension points allow the customization<br/>of all mentioned aspects. It is possible to contribute a custom type<br/>system or custom action languages which may be a dialect of SText or a<br/>complete new language.<br/>Also, the different code generators can be customized or new code<br/>generators for other target languages can be plugged in easily.</p><h2 id="Howdoesitwork">How does it work?</h2><p>The YAKINDU SCT 2 are integrated in Eclipse and use the textual modeling toolkit Xtext and the graphical modeling toolkit GMF. Behind the scenes of the statechart tools there are some meta models: </p><ul><li><strong>SText</strong> the meta model for the state machines and their behavior</li><li><strong>SGraph</strong> the meta model for the graphical representation of the state machine models</li><li><strong>SExec</strong> an intermediate model for execution</li><li><strong>SGen</strong> an intermediate model used for generating</li></ul><p>The following graph shows these meta models, which are all defined as languages and their position in the SCT 2 work flow:</p><p><img border="0" src="images/overview_yakindu_modules_tech.jpg"/></p><p>The statechart editor uses <strong>SText</strong> and <strong>SGraph</strong>. The actual model of the state machine is defined in <strong>SText</strong>. <strong>SGraph</strong> only describes the graphical representation in the editor. <strong>SExec</strong> is an intermediate execution model. It is used behind the scenes as a foundation for the code generators and the simulation engine. This guarantees that the simulation behaves in the same way as the generated statechart implementations. It captures the execution behavior and may also serve as the basis of custom code generators. <strong>SGen</strong> is a generator model. All generators can be customized with such a generator model. In fact it is a textual model file where generator features, like i.e. the outlet path, can be specified.</p><p>The YAKINDU SCT 2 can be installed in a full blown Eclipse-IDE specifically tailored for your language. It already provides great default functionality for all aspects and allows to configure  the most common things very easily. </p><h2 id="WhoisbehindYAKINDUStatechartTools2">Who is behind YAKINDU Statechart Tools 2?</h2><p>The main part of YAKINDU SCT 2 is an open source project (<a href="http://www.yakindu.org">www.yakindu.org</a> ). Most of the developers work for itemis, a well known consulting company specialized on model based development.  </p><p>You may ask: Where does the money for Open-Source development come from? Well, we provide professional services around Yakindu. Be it training or on-site consulting, be it development of prototypes or implementation of full-blown IDEs for programming languages. We do not only know the framework very well but we are also experts in programming and domain-specific language design. If you need an advice get in contact with us (<a href="http://www.yakindu.de">www.yakindu.de</a> ). </p><h2 id="WhousestheYAKINDUStatechartTools2">Who uses the YAKINDU Statechart Tools 2?</h2><p>Initially the YAKINDU SCT 2 were designed for the embedded systems industry: automotive, system controls, vending machines etc. But it brings benefit to everyone who needs to design, simulate and develop behavior. People can use the YAKINDU SCT 2 to generate Java, C, or C++.</p></body></html>