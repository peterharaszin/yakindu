<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<title>tasks</title>
		<link type="text/css" rel="stylesheet" href="../style.css"/>
	</head>
	<body>
		<h1 id="Tasks">Tasks</h1>
		<h2 id="Modelingastatemachine">Modeling a statemachine</h2>
		<ol>
			<li>Make sure the YAKINDU Modeling perspective is active.</li>
			<li>Create a new project.</li>
			<li>Click 
				<strong>File</strong> &gt; 
				<strong>New</strong> &gt; 
				<strong>Other...</strong> &gt; 
				<strong>YAKINDU</strong> &gt; 
				<strong>YAKINDU Statechart Model</strong>. 
			</li>
			<li>Click 
				<strong>Next</strong> name the sct file and click 
				<strong>Finish</strong>
			</li>
			<li>The YAKINDU statechart editor opens on the statechart model. It already has an initial state and an unnamed simple state connected by a transition.</li>
			<li>Now you can add states and transitions from the palette.</li>
		</ol>
		<p>To edit the states and transitions you can use the properties view. It has an integrated Xtext support. This makes correct editing easier. You can also change the appearance of the model elements. </p>
		<p>On the palette you will also find a composite submachine state. This is a state that contains a complete statemachine. You can choose an existing statemachine or create a new one.</p>
		<h3 id="Relatedtopics">Related topics</h3>
		<p>
			<a href="../05_Reference/reference.html#Statechartelements">Statemachine Elements reference</a>
			<br/>
			<a href="../05_Reference/reference.html#Statechartdescriptionlanguage">Textual modeling lanuage  Reference</a>
		</p>
		<h2 id="Validatingastatemachine">Validating a statemachine</h2>
		<p>The statemachine is validated automatically during build. The elements that cause problems get error markers. You can find the details about the problems on the problems view.</p>
		<h2 id="Simulatingastatemachine">Simulating a statemachine</h2>
		<p>The YAKINDU simulation engine supports simulation modes:</p>
		<ul>
			<li>event driven</li>
			<li>cycle based</li>
		</ul>
		<p>The default setting is 
			<em>cycle based</em> with a cycle period of 200 ms. In this mode the simulation engine processes the state machine transitions in steps of the given cycle duration. The following statechart illustrates this. It is simulated cycle based with a cycle period of 3 seconds.
		</p>
		<p>
			<img border="0" src="images/cycleBasedVsEventDriven.png"/>
		</p>
		<p>What happend during simulation is the following:</p>
		<ol>
			<li>After 3s 
				<strong>init</strong> switches to 
				<strong>pre1</strong>
			</li>
			<li>After 3 further seconds recursive transition to 
				<strong>pre1</strong> is processed (not after 2s the transition says)
			</li>
			<li>After 3 further seconds recursive transition to 
				<strong>pre1</strong> is processed again and the condition becomes 
				<strong>true</strong> so 
				<strong>result</strong> gets activated
			</li>
		</ol>
		<p>In contrast to cycle based the event driven simulation mode concentrates on the events of a state machine. The same state machine above could be simulated as follows:</p>
		<ol>
			<li>Immediately 
				<strong>init</strong> switches to 
				<strong>pre1</strong>
			</li>
			<li>Immediately the event 
				<strong>touch</strong> is raised twice
			</li>
			<li>The condition becomes true so that the 
				<strong>result</strong> state is reached after 2 or 3 seconds instead of 9 
			</li>
		</ol>
		<p>Start a simulation with the different modes as follows</p>
		<ol>
			<li>Make sure the YAKINDU Simulation Perspectiv is opened.</li>
			<li>Start the simulation by clicking 
				<strong>Run</strong> &gt; 
				<strong>Run Configurations...</strong>.
			</li>
			<li>Select the statechart you want to simulate and the simulation mode.</li>
			<li>
				<strong>Apply</strong> the setting and 
				<strong>Run</strong> the simulation.
			</li>
		</ol>
		<p>
			<img border="0" src="images/simulationRunConfiguration.png"/>
		</p>
		<p>
			<a href="../03_Concepts/concepts.html#Simulation">Simulation Concept</a>
			<br/>
			<a href="../03_Concepts/concepts.html#YakinduSCSimulationperspective">Simulation perspective</a>
			<br/>
			<a href="../03_Concepts/concepts.html#SimulationView">Simulation View</a>
		</p>
		<h2 id="GeneratingCode">Generating Code</h2>
		<p>For code generation, Yakindu Statechart Tools uses a textual generator model called 
			<strong>SGen</strong>, that can be used to configure the code generation process. It can be created either by using the provided wizard or by creating a new text file with the file extension &#8218;.sgen&#8217;.
			<br/>To create a generator model with the wizard,
		</p>
		<ol>
			<li>Click 
				<strong>File</strong> &gt; 
				<strong>New</strong> &gt; 
				<strong>Other...</strong> &gt; 
				<strong>Yakindu Statechart Genmodel</strong>
			</li>
			<li>Type a name and click 
				<strong>Next</strong>
			</li>
			<li>Choose the desired generator, i.e. 
				<strong>YAKINDU Java Code Generator</strong>
			</li>
			<li>Check the model(s) to generate code from and click 
				<strong>Finish</strong>
			</li>
		</ol>
		<p>
			<img border="0" src="images/genmodelwizardchooselanguage.jpg"/>
		</p>
		<p>The result is an .sgen file of the following format: </p>
		<pre><code>GeneratorModel for [GeneratorId] {
	statechart [StatechartReference] {
		feature [Feature] {
			[ParameterName] = [ParameterValue]
		}
	}
}
</code></pre>
		<p>The [GeneratorId] is the unique id of the Generator. Yakindu Statechart Tools currently supports the following Generators out of the box:</p>
		<ol>
			<li>yakindu::java &#8211; Generator ID for the Java Code Generator </li>
			<li>yakindu::c &#8211; Generator ID for the C Code Generator</li>
			<li>yakindu::cpp &#8211; Generator ID for the C++ Code Generator</li>
		</ol>
		<p>One GeneratorModel can contain several [StatechartReference]s. These are crossreference to statechart models for which the code should be generated. 
			<br/>For each referenced Statechart, the generator process can be configured with [Feature]s. Each Feature consists of several parameters. These parameters can be configured with [ParameterName] = [ParameterValue].
		</p>
		<p>The Generator Model will be build automatically if you checked 
			<strong>Project</strong> &gt; 
			<strong>Build Automatically</strong>. If you want to execute only one Generator Model, you can select  
			<br/>
			<strong>Generate Statechart Artifacts</strong> from the 
			<strong>Package Explorer&#8217;s</strong> context menu.
		</p>
		<h2 id="CoreFeatures">Core Features</h2>
		<p>The following section describes the 
			<strong>Core Features</strong> which are available for each Code Generator:
		</p>
		<h4 id="Outlet">Outlet</h4>
		<p>The 
			<strong>Outlet</strong> feature specifies the target project and folder for the generated artifacts. It is a 
			<strong>required</strong> feature and consists of the following parameters:
		</p>
		<ol>
			<li>
				<i>targetProject</i>  (String): The project where the generated artifacts are stored  
			</li>
			<li>
				<i>targetFolder</i>  (String): The folder where the generated artifacts are stored
			</li>
		</ol>
		<p>Example configuration:</p>
		<pre><code>feature Outlet {
	targetProject = "ExampleProject"
	targetFolder = "src-gen"
}
</code></pre>
		<p><!-- End Outlet --></p>
		<h4 id="LicenseHeader">LicenseHeader</h4>
		<p>The 
			<strong>LicenseHeader</strong> feature specifies the license text that should be added as a header to the generated artifacts. It is an 
			<strong>optinal</strong> feature and consists of the following parameters:
		</p>
		<ol>
			<li>
				<i>licenseText</i>  (String): The license text to add as a header  
			</li>
		</ol>
		<p>Example configuration:</p>
		<pre><code>feature LicenseHeader {
	licenseText = "Copyright (c) 2012 committers of YAKINDU and others."
}
</code></pre>
		<p><!-- End LicenseHeader --></p>
		<h4 id="FunctionInlining">FunctionInlining</h4>
		<p>The 
			<strong>FunctionInlining</strong> feature allows the inlining of expressions instead of generating separate functions or methods. This might reduce the readability of the generated code, but increases performance because less operation calls are neccessary. 
			<br/>It is an 
			<strong>optinal</strong> feature and consists of the following parameters:
		</p>
		<ol>
			<li>
				<i>inlineReactions</i>  (Boolean): Inlines the expression for reactions
			</li>
			<li>
				<i>inlineEntryActions</i>  (Boolean): Inlines the expression for entry actions
			</li>
			<li>
				<i>inlineExitActions</i>  (Boolean): Inlines the expression for exit actions
			</li>
			<li>
				<i>inlineEnterSequences</i>  (Boolean): Inlines the expression for enter sequences
			</li>
			<li>
				<i>inlineExitSequences</i>  (Boolean): Inlines the expression for exit sequences
			</li>
			<li>
				<i>inlineChoices</i>  (Boolean): Inlines the expression for choices
			</li>
			<li>
				<i>inlineEnterRegion</i>  (Boolean): Inlines the expression for enter regions
			</li>
			<li>
				<i>inlineExitRegion</i>  (Boolean): Inlines the expression for exit regions
			</li>
			<li>
				<i>inlineEntries</i>  (Boolean): Inlines the expression for entries 
			</li>
		</ol>
		<p>Example configuration:</p>
		<pre><code>feature FunctionInlining {
	inlineChoices = false
	inlineEnterRegion = true
	inlineEntries = true
}
</code></pre>
		<p><!-- End FunctionInlining --></p>
		<h2 id="JavaGeneratorFeatures">Java Generator Features</h2>
		<h4 id="Naming">Naming</h4>
		<p>The 
			<strong>Naming</strong> feature allows the configuration of package names as well as class name prefix / suffix.
			<br/>It is an 
			<strong>optinal</strong> feature and consists of the following parameters:
		</p>
		<ol>
			<li>
				<i>basePackage</i>  (Boolean): Inlines the expression for reactions
			</li>
			<li>
				<i>implementationSuffix</i>  (Boolean): Inlines the expression for entry actions
			</li>
		</ol>
		<p>Example configuration:</p>
		<pre><code>feature Naming {
	basePackage = "org.yakindu.sct"
	implementationSuffix = "Impl"
}
</code></pre>
		<p><!-- End Naming -->	</p>
		<h4 id="GeneralFeatures">GeneralFeatures
			TBD</h4>
		<h2 id="CGeneratorFetures">C Generator Fetures
			TBD</h2>
		<p>}</p>
	</body>
</html>