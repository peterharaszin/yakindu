«REM»

Templates for the main statechart c file.

@auther joern seger

«ENDREM»

«IMPORT sexec»
«IMPORT stext»
«IMPORT sgraph»
«IMPORT ecore»

«IMPORT org::yakindu::sct::generator::c::templates»

«EXTENSION org::yakindu::sct::generator::c::templates::Expression»
«EXTENSION org::yakindu::sct::generator::c::templates::Constants»
«EXTENSION org::yakindu::sct::generator::c::templates::Naming»
 
«DEFINE ActionCode FOR Step»
/* ActionCode for Step not defined */
«ENDDEFINE»

«DEFINE ActionCode FOR StateSwitch»
«IF this.comment != null»
/* «this.comment» */
«ENDIF»
	switch(((StatemachineBase*)handle)->state[0/* TODO: must be set correctly */]) {
«FOREACH this.cases AS caseid»
  case _«caseid.state.simpleName» : {
  «EXPAND ActionCode FOR caseid.step»
  break;
  }
«ENDFOREACH»
  default:
    break;
	}
«ENDDEFINE»

«DEFINE ActionCode FOR ScheduleTimeEvent»
«IF this.comment != null»
/* «this.comment» */
«ENDIF»
	(*((StatemachineBase*)handle)->timer->setTimer)(«this.timeEvent.getEventEnumName()», «this.timeValue.toCCode()», «IF this.timeEvent.periodic == true -» «getBoolTrue()» «ELSE -» «getBoolFalse()» «ENDIF -»);
«ENDDEFINE»

«DEFINE ActionCode FOR UnscheduleTimeEvent»
«IF this.comment != null»
/* «this.comment» */
	(*((StatemachineBase*)handle->timer->unsetTimer)(«this.timeEvent.getEventEnumName()»);
«ENDIF»

«ENDDEFINE»

«DEFINE ActionCode FOR Execution»
	«this.statement.toCCode()»
«ENDDEFINE»

«DEFINE ActionCode FOR Call»
«this.step.functionName()»(handle);
«ENDDEFINE»

«DEFINE ActionCode FOR Sequence»
  «EXPAND ActionCode FOREACH this.steps»
«ENDDEFINE»

«DEFINE ActionCode FOR Check -»
  «IF this != null -»
«this.condition.toCCode() -»
  «ELSE -»
 «getBoolTrue()» «
 ENDIF -»«
  ENDDEFINE»

«DEFINE ActionCode FOR CheckRef -»
  «IF this.check != null -»
  «this.check.functionName()»(handle) «
  ELSE -»
 «getBoolTrue()» «
  ENDIF -»«
ENDDEFINE»

«DEFINE ActionCode FOR Reaction»
  «EXPAND ActionCode FOR this.effect» 
«ENDDEFINE»

«DEFINE ActionCode FOR If»
if («EXPAND ActionCode FOR this.check») { 
  «EXPAND ActionCode FOR this.thenStep»
}
«IF (this.elseStep != null)»
else {
  «EXPAND ActionCode FOR this.elseStep»
}
«ENDIF»
«ENDDEFINE»

«DEFINE ActionCode FOR EnterState»
((StatemachineBase*)handle)->state[0] = _«this.state.simpleName»;
«ENDDEFINE»

«DEFINE ActionCode FOR ExitState»
((StatemachineBase*)handle)->state[0] = last_state;
«ENDDEFINE»

«DEFINE ConditionMethodsProto FOR ExecutionNode -»
  «FOREACH reactions.select(e|e.check.refs.size > 0) AS r -»
  «IF r.check != null -»
static boolean «r.check.functionName()»(«StName()»* handle);
  «ENDIF -»«ENDFOREACH -»
«ENDDEFINE»

«DEFINE ConditionMethodsImplement FOR ExecutionNode -»
  «FOREACH reactions.select(e|e.check.refs.size > 0) AS r -»
  «IF r.check != null -»
boolean «r.check.functionName()»(«StName()»* handle) {
  boolean retValue = «getBoolFalse()»;
  if («r.check.condition.toCCode()»)
    retValue = «getBoolTrue()»;
  
  return retValue;
}
  «ENDIF -»
  «ENDFOREACH -»
«ENDDEFINE»

«DEFINE StatementMethodsProto FOR ExecutionNode -»
  «FOREACH reactions.select(e|e.effect.caller.size > 0) AS r -»
static void «r.effect.functionName()»(«StName()»* handle);
 «ENDFOREACH -»
«ENDDEFINE»

«DEFINE StatementMethodsImplement FOR ExecutionNode -»
  «FOREACH reactions.select(e|e.effect.caller.size > 0) AS r -»
void «r.effect.functionName()»(«StName()»* handle) {   
  «EXPAND ActionCode FOR r.effect -»
}
  «ENDFOREACH -»
«ENDDEFINE»

«DEFINE ReactCode FOR Sequence» 
«EXPAND ActionCode FOREACH this.steps»
«ENDDEFINE»

«DEFINE ReactMethodsProto FOR ExecutionNode -»
«IF (ExecutionState.isInstance(this) || this.reactSequence.caller.size > 0) -»
static void «stName()»_react_«this.simpleName»(«StName()»* handle);
«ENDIF -»
«ENDDEFINE»

«DEFINE ReactMethodsImplement FOR ExecutionNode -»
«IF (ExecutionState.isInstance(this) || this.reactSequence.caller.size > 0) -»
void «stName()»_react_«this.simpleName»(«StName()»* handle)
{
	«EXPAND ReactCode FOR reactSequence»
}
«ENDIF -»
«ENDDEFINE»

«DEFINE EnterMethodProto FOR ExecutionState -»
«IF this.entryAction != null && entryAction.caller.size > 0 -»
static void «this.entryAction.entryActionFunctionName()»(«StName()»* handle);
«ENDIF -»
«ENDDEFINE»

«DEFINE EnterMethodImplement FOR ExecutionState -»
«IF this.entryAction != null && entryAction.caller.size > 0»
void «this.entryAction.entryActionFunctionName()»(«StName()»* handle)
{
«EXPAND ActionCode FOR this.entryAction»
}
«ENDIF -»
«ENDDEFINE»

«DEFINE ExitMethodProto FOR ExecutionState -»
«IF this.exitAction != null && exitAction.caller.size > 0 -»
static void «this.exitAction.exitActionFunctionName()»(«StName()»* handle);
«ENDIF -»
«ENDDEFINE»

«DEFINE ExitMethodImplement FOR ExecutionState -»
«IF this.exitAction != null && exitAction.caller.size > 0 »
void «this.exitAction.exitActionFunctionName()»(«StName()»* handle)
{
«EXPAND ActionCode FOR this.exitAction»
}
«ENDIF -»
«ENDDEFINE»



«DEFINE EnterSequenceProto FOR ExecutionState -»
«IF this.enterSequence != null && enterSequence.caller.size > 0 -»
static void «this.enterSequence.enterSequenceFunctionName()»(«StName()»* handle);
«ENDIF -»
«ENDDEFINE»

«DEFINE EnterSequenceImplement FOR ExecutionState -»
«IF this.enterSequence != null && enterSequence .caller.size > 0 »
void «this.enterSequence.enterSequenceFunctionName()»(«StName()»* handle)
{
«EXPAND ActionCode FOR this.enterSequence»
}
«ENDIF -»
«ENDDEFINE»

«DEFINE ExitSequenceProto FOR ExecutionState -»
«IF this.exitSequence != null && exitSequence.caller.size > 0 -»
static void «this.exitSequence.exitSequenceFunctionName()»(«StName()»* handle);
«ENDIF -»
«ENDDEFINE»

«DEFINE ExitSequenceImplement FOR ExecutionState -»
«IF this.exitSequence != null && exitSequence.caller.size > 0 -»
void «this.exitSequence.exitSequenceFunctionName()»(«StName()»* handle)
{
«EXPAND ActionCode FOR this.exitSequence»
}
«ENDIF -»
«ENDDEFINE»



«DEFINE file(sgen::GeneratorEntry genEntry) FOR ExecutionFlow»
«FILE StName()+'.c'»
«getLicenseHeader(genEntry)»

#define «STNAME()»_FRIENDS

#include "«StName()».h"

«EXPAND ConditionMethodsProto FOREACH this.states -»
«EXPAND ConditionMethodsProto FOREACH this.nodes -»
«EXPAND StatementMethodsProto FOREACH this.states -»
«EXPAND StatementMethodsProto FOREACH this.nodes -»
«EXPAND EnterMethodProto FOREACH this.states -»
«EXPAND ExitMethodProto FOREACH this.states -»
«EXPAND EnterSequenceProto FOREACH this.states -»
«EXPAND ExitSequenceProto FOREACH this.states -»
«EXPAND ReactMethodsProto FOREACH this.states -»
«EXPAND ReactMethodsProto FOREACH this.nodes -»

«EXPAND ConditionMethodsImplement FOREACH this.states -»
«EXPAND ConditionMethodsImplement FOREACH this.nodes -»
«EXPAND StatementMethodsImplement FOREACH this.states -»
«EXPAND StatementMethodsImplement FOREACH this.nodes -»
«EXPAND EnterMethodImplement FOREACH this.states -»
«EXPAND ExitMethodImplement FOREACH this.states -»
«EXPAND EnterSequenceImplement FOREACH this.states -»
«EXPAND ExitSequenceImplement FOREACH this.states -»
«EXPAND ReactMethodsImplement FOREACH this.states -»
«EXPAND ReactMethodsImplement FOREACH this.nodes -»

«REM»
boolean «stName()»_is_in(«StName()»* handle, States state)
{
	switch (((StatemachineBase*)handle)->state[0 /* TODO: change to correct parallel region (may need a for loop */]) {
	«FOREACH this.states AS state»
	    case _«state.simpleName»:
			«IF state.leaf == true»
			  return bool_true;
			«ELSE»
			  if ( bool_true == bool_true )
			    return bool_true;
			«ENDIF»  
	        break;
	«ENDFOREACH»
	    default:
	        break;
	}
	return bool_false;
}
«ENDREM»
void «stName()»_init(«StName()»* handle, Timer* timer, EventPool* eventPool)
{
	statemachine_cy_init(&handle->base, MAX_PARALLEL_STATES,
			event_last, timer, eventPool);
			
«FOREACH this.scopes.getUsableScopes() AS interface -»
	«interface.interfaceName()»_init(&handle->«interface.interfaceObjectName().toFirstLower()», &handle->base, &handle->base.eventSet, eventPool);

«FOREACH interface.getInEvents() AS event -»
	eventSet_set_type(&handle->base.eventSet, «event.getEventEnumName()», ev_type_input); 
«ENDFOREACH -»
«FOREACH interface.getOutEvents() AS event -»
	eventSet_set_type(&handle->base.eventSet, «event.getEventEnumName()», ev_type_output); 
«ENDFOREACH -»
«FOREACH interface.getLocalEvents() AS event -»
	eventSet_set_type(&handle->base.eventSet, «event.getEventEnumName()», ev_type_local); 
«ENDFOREACH -»

«ENDFOREACH»	
	
}

«FOREACH this.scopes.typeSelect(InterfaceScope) AS interface»
extern «interface.interfaceClassName()»* «stName()»_get_«interface.interfaceObjectName().toFirstLower()»(«StName()»* handle)
{
  return &handle->«interface.interfaceObjectName()»;
}
«ENDFOREACH»

void «stName()»_enter(«StName()»* handle)
{
	«EXPAND ActionCode FOR this.enterSequence»
}

void «stName()»_exit(«StName()»* handle)
{
	«EXPAND ActionCode FOR this.exitSequence»
}

void «stName()»_destruct(«StName()»* handle)
{
	statemachine_cy_destruct(&handle->base);
«REM»	variableData_exit(&handle->variableData); «ENDREM»
}

void «stName()»_runCycle(«StName()»* handle)
{
	statemachine_cy_runCycle(&handle->base);
}

void «stName()»_setEvent(«StName()»* handle, _Event* ev)
{
	statemachine_cy_setEvent(&handle->base, ev);
}

boolean «stName()»_eventWaiting(«StName()»* handle)
{
	return statemachine_cy_eventWaiting(&handle->base);
}


void statemachine_cy__runCycle(Statemachine_cy* handle)
{
	uint32_t i;
	for (i=0; i<MAX_PARALLEL_STATES; ++i) {
		switch(((StatemachineBase*)handle)->state[i]) {
	«FOREACH this.states AS state»
	    case _«state.simpleName»:
	        «stName()»_react_«state.simpleName»((«StName()»*) handle);
	        break;
	«ENDFOREACH»
		default:
			/* no state found */
			break;
		}
	}
}
«ENDFILE»

«ENDDEFINE»