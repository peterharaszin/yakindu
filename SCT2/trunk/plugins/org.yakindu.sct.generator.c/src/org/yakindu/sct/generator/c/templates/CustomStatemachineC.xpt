«REM»

Templates for the main statechart c file.

@auther joern seger

«ENDREM»

«IMPORT sexec»
«IMPORT stext»
«IMPORT sgraph»
«IMPORT ecore»
«IMPORT genmodel»

«IMPORT org::yakindu::sct::generator::c::templates»

«EXTENSION org::yakindu::sct::generator::c::templates::Expression»
«EXTENSION org::yakindu::sct::generator::c::templates::Constants»
«EXTENSION org::yakindu::sct::generator::c::templates::Naming»
 
«DEFINE ActionCode FOR Step»
#warning ActionCode for Step not defined 
«ENDDEFINE»

«DEFINE ActionCode FOR StateSwitch»
«IF this.comment != null -»
	/* «this.comment» */
«ENDIF -»
	switch(((StatemachineBase*)«statemachineHandleName()»)->state[ «this.stateConfigurationIdx» ]) {
«FOREACH this.cases AS caseid -»
		case _«caseid.state.simpleName» : {
«EXPAND ActionCode FOR caseid.step-»
			break;
		}
«ENDFOREACH»
		default: break;
	}
«ENDDEFINE »

«DEFINE ActionCode FOR ScheduleTimeEvent»
«IF this.comment != null»
/* «this.comment» */
«ENDIF»
	(*((StatemachineBase*)«statemachineHandleName()»)->timer->setTimer)(«this.timeEvent.getEventEnumName()», «this.timeValue.toCCode()», «IF this.timeEvent.periodic == true -» «getBoolTrue()» «ELSE -» «getBoolFalse()» «ENDIF -»);
«ENDDEFINE»

«DEFINE ActionCode FOR UnscheduleTimeEvent»
«IF this.comment != null»
/* «this.comment» */
«ENDIF»
	(*((StatemachineBase*)«statemachineHandleName()»)->timer->unsetTimer)(«this.timeEvent.getEventEnumName()»);
«ENDDEFINE»

«DEFINE ActionCode FOR Execution»
	«this.statement.toCCode()»
«ENDDEFINE»

«DEFINE ActionCode FOR Call»
«this.step.functionName()»(«IF isSingleton() == false»(«StName()»*) handle«ENDIF»);
«ENDDEFINE»

«DEFINE ActionCode FOR Sequence»
  «EXPAND ActionCode FOREACH this.steps»
«ENDDEFINE»

«DEFINE ActionCode FOR Check -»
  «IF this != null -»
«this.condition.toCCode() -»
  «ELSE -»
 «getBoolTrue()» «
 ENDIF -»«
  ENDDEFINE»

«DEFINE ActionCode FOR CheckRef -»
  «IF this.check != null -» 
 #error Action Code for CheckRef missing
  «REM»
  «this.check.functionName()»(handle) «
  «ENDREM»
  «ELSE -»
 «getBoolTrue()» «
  ENDIF -»«
ENDDEFINE»

«DEFINE ActionCode FOR Reaction»
  «EXPAND ActionCode FOR this.effect» 
«ENDDEFINE»

«DEFINE ActionCode FOR If»
if («EXPAND ActionCode FOR this.check») { 
  «EXPAND ActionCode FOR this.thenStep»
}
«IF (this.elseStep != null)»
else {
  «EXPAND ActionCode FOR this.elseStep»
}
«ENDIF»
«ENDDEFINE»


«DEFINE ActionCode FOR EnterState»
((StatemachineBase*)«statemachineHandleName()»)->state[«this.state.stateVector.offset»] = _«this.state.simpleName»;
((Statemachine_cy*)«statemachineHandleName()»)->parallelPosition = «this.state.stateVector.offset»;
«ENDDEFINE»

«DEFINE ActionCode FOR ExitState»
((StatemachineBase*)«statemachineHandleName()»)->state[«this.state.stateVector.offset»] = last_state;
((Statemachine_cy*)«statemachineHandleName()»)->parallelPosition = «this.state.stateVector.offset»;
«ENDDEFINE»

«DEFINE ConditionMethodsProto FOR ExecutionNode -»
  «FOREACH reactions.select(e|e.check.refs.size > 0) AS r -»
  «IF r.check != null -»
static boolean «r.check.checkFunction()»; 
  «ENDIF -»«ENDFOREACH -»
«ENDDEFINE»

«DEFINE ConditionMethodsImplement FOR ExecutionNode -»
  «FOREACH reactions.select(e|e.check.refs.size > 0) AS r -»
  «IF r.check != null -»
boolean «r.check.checkFunction()» {
  boolean retValue = «getBoolFalse()»;
  if («r.check.condition.toCCode()»)
    retValue = «getBoolTrue()»;
  
  return retValue;
}
  «ENDIF -»
  «ENDFOREACH -»
«ENDDEFINE»

«DEFINE StatementMethodsProto FOR ExecutionNode -»
/* statement method prototypes */
  «FOREACH reactions.select(e|e.effect.caller.size > 0) AS r -»
static void «r.reactFunction()»;
 «ENDFOREACH -»
«ENDDEFINE»

«DEFINE StatementMethodsImplement FOR ExecutionNode -»
/* statement method implementations */
  «FOREACH reactions.select(e|e.effect.caller.size > 0) AS r -»
void «r.reactFunction()»
{   
  «EXPAND ActionCode FOR r.effect -»
}
  «ENDFOREACH -»
«ENDDEFINE»

«DEFINE ReactCode FOR Sequence» 
«EXPAND ActionCode FOREACH this.steps»
«ENDDEFINE»

«DEFINE ReactMethodsProto FOR ExecutionNode -»
«IF (ExecutionState.isInstance(this) || this.reactSequence.caller.size > 0) -»
static void «this.reactFunction()»;
«REM»«stName()»_react_«this.simpleName»(«StName()»* handle);«ENDREM»
«ENDIF -»
«ENDDEFINE»

«DEFINE ReactMethodsImplement FOR ExecutionNode -»
«IF (ExecutionState.isInstance(this) || this.reactSequence.caller.size > 0) -»
void «this.reactFunction()»
«REM»void «stName()»_react_«this.simpleName»(«StName()»* handle)«ENDREM»
{
	«EXPAND ReactCode FOR reactSequence»
}
«ENDIF -»
«ENDDEFINE»

«DEFINE EnterMethodProto FOR ExecutionState -»
«IF this.entryAction != null && entryAction.caller.size > 0 -»
static void «entryAction.entryActionFunction()»;
«ENDIF -»
«ENDDEFINE»

«DEFINE EnterMethodImplement FOR ExecutionState -»
«IF this.entryAction != null && entryAction.caller.size > 0»
void «entryAction.entryActionFunction()»
{
«EXPAND ActionCode FOR this.entryAction»
}
«ENDIF -»
«ENDDEFINE»

«DEFINE ExitMethodProto FOR ExecutionState -»
«IF this.exitAction != null && exitAction.caller.size > 0 -»
static void «this.exitAction.exitActionFunction()»;
«ENDIF -»
«ENDDEFINE»

«DEFINE ExitMethodImplement FOR ExecutionState -»
«IF this.exitAction != null && exitAction.caller.size > 0 »
void «this.exitAction.exitActionFunction()»
{
«EXPAND ActionCode FOR this.exitAction»
}
«ENDIF -»
«ENDDEFINE»



«DEFINE EnterSequenceProto FOR ExecutionState -»
«IF this.enterSequence != null && enterSequence.caller.size > 0 -»
static void «this.enterSequence.enterSequenceFunction()»;
«ENDIF -»
«ENDDEFINE»

«DEFINE EnterSequenceImplement FOR ExecutionState -»
«IF this.enterSequence != null && enterSequence .caller.size > 0 »
void «this.enterSequence.enterSequenceFunction()»
{
«EXPAND ActionCode FOR this.enterSequence»
}
«ENDIF -»
«ENDDEFINE»

«DEFINE ExitSequenceProto FOR ExecutionState -»
«IF this.exitSequence != null && exitSequence.caller.size > 0 -»
static void «this.exitSequence.exitSequenceFunction()»;
«ENDIF -»
«ENDDEFINE»

«DEFINE ExitSequenceImplement FOR ExecutionState -»
«IF this.exitSequence != null && exitSequence.caller.size > 0 -»
void «this.exitSequence.exitSequenceFunction()»
{
«EXPAND ActionCode FOR this.exitSequence»
}
«ENDIF -»
«ENDDEFINE»



«DEFINE file FOR ExecutionFlow»
«FILE StName()+'.c'»
«this.getLicenseHeader()»

#define «STNAME()»_FRIENDS

#include "«StName()».h"

«IF this.isSingleton() == true»
/* singleton handle and singleton handle pointer declaration */
static «StName()» static_«statemachineHandleName()»;
static «StName()»* «statemachineHandleName()»;
«ENDIF»

«EXPAND ConditionMethodsProto FOREACH this.states -»
«EXPAND ConditionMethodsProto FOREACH this.nodes -»
«EXPAND StatementMethodsProto FOREACH this.states -»
«EXPAND StatementMethodsProto FOREACH this.nodes -»
«EXPAND EnterMethodProto FOREACH this.states -»
«EXPAND ExitMethodProto FOREACH this.states -»
«EXPAND EnterSequenceProto FOREACH this.states -»
«EXPAND ExitSequenceProto FOREACH this.states -»
«EXPAND ReactMethodsProto FOREACH this.states -»
«EXPAND ReactMethodsProto FOREACH this.nodes -»

«EXPAND ConditionMethodsImplement FOREACH this.states -»
«EXPAND ConditionMethodsImplement FOREACH this.nodes -»
«EXPAND StatementMethodsImplement FOREACH this.states -»
«EXPAND StatementMethodsImplement FOREACH this.nodes -»
«EXPAND EnterMethodImplement FOREACH this.states -»
«EXPAND ExitMethodImplement FOREACH this.states -»
«EXPAND EnterSequenceImplement FOREACH this.states -»
«EXPAND ExitSequenceImplement FOREACH this.states -»
«EXPAND ReactMethodsImplement FOREACH this.states -»
«EXPAND ReactMethodsImplement FOREACH this.nodes -»

void «stName()»_init(«this.handleAdditionComma()» Timer* timer, EventPool* eventPool)
{
	int i;
	
«IF this.isSingleton()»
	«statemachineHandleName()» = &static_«statemachineHandleName()»;
«ENDIF»
	statemachine_cy_init(&«statemachineHandleName()»->base, MAX_PARALLEL_STATES,
			event_last, timer, eventPool);

	for (i = 0; i<MAX_PARALLEL_STATES; ++i)
		«statemachineHandleName()»->base.base.state[i] = last_state;
			
«FOREACH this.scopes.getUsableScopes() AS interface -»
«IF this.isSingleton() -»
     «interface.interfaceName()»_set_interface_singleton(&«statemachineHandleName()»->«interface.interfaceObjectName()»);
     «interface.interfaceName()»_init(&«statemachineHandleName()»->base, &«statemachineHandleName()»->base.eventSet, eventPool);
«ELSE -»
	«interface.interfaceName()»_init(&«statemachineHandleName()»->«interface.interfaceObjectName().toFirstLower()», 
	&«statemachineHandleName()»->base, &«statemachineHandleName()»->base.eventSet, eventPool);
«ENDIF»

«FOREACH interface.getInEvents() AS event -»
	eventSet_set_type(&«statemachineHandleName()»->base.eventSet, «event.getEventEnumName()», ev_type_input); 
«ENDFOREACH -»
«FOREACH interface.getOutEvents() AS event -»
	eventSet_set_type(&«statemachineHandleName()»->base.eventSet, «event.getEventEnumName()», ev_type_output); 
«ENDFOREACH -»
«FOREACH interface.getLocalEvents() AS event -»
	eventSet_set_type(&«statemachineHandleName()»->base.eventSet, «event.getEventEnumName()», ev_type_local); 
«ENDFOREACH -»
«ENDFOREACH»	
}

«IF this.isSingleton() == true»
«StName()»* «scName()»_get_handle()
{ return «statemachineHandleName()»; } 
«ELSE»
«FOREACH this.scopes.typeSelect(InterfaceScope) AS interface»
extern «interface.interfaceClassName()»* «stName()»_get_«interface.interfaceObjectName().toFirstLower()»(«handleAddition()»)
{  return &«statemachineHandleName()»->«interface.interfaceObjectName()»; }
«ENDFOREACH»
«ENDIF»

void «stName()»_enter(«handleAddition()»)
{
	«EXPAND ActionCode FOR this.enterSequence»
}

void «stName()»_exit(«handleAddition()»)
{
	«EXPAND ActionCode FOR this.exitSequence»
}

void «stName()»_destruct(«handleAddition()»)
{
	statemachine_cy_destruct(&«statemachineHandleName()»->base);
}

void «stName()»_runCycle(«handleAddition()»)
{
	statemachine_cy_runCycle(&«statemachineHandleName()»->base);
}

void «stName()»_setEvent(«handleAdditionComma()» _Event* ev)
{
	statemachine_cy_setEvent(&«statemachineHandleName()»->base, ev);
}

boolean «stName()»_eventWaiting(«handleAddition()»)
{
	return statemachine_cy_eventWaiting(&«statemachineHandleName()»->base);
}

void statemachine_cy__runCycle(Statemachine_cy* handle)
{
	for (handle->parallelPosition=0; 
	     handle->parallelPosition<MAX_PARALLEL_STATES; 
	     ++handle->parallelPosition) {
		switch(((StatemachineBase*)handle)->state[handle->parallelPosition]) {
	«FOREACH this.states AS state»
	    case _«state.simpleName»:
			«state.reactFunctionName()»(«IF isSingleton() == false»(«StName()»*) handle«ENDIF»);
	        break;
	«ENDFOREACH»
		default:
			/* no state found */
			break;
		}
	}
}
«ENDFILE»

«ENDDEFINE»