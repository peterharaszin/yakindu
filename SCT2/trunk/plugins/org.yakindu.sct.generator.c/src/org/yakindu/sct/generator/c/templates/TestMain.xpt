«REM»

Templates for the main statechart cpp file.

@auther joern seger

«ENDREM»

«IMPORT sexec»
«IMPORT stext»
«IMPORT sgraph»

«EXTENSION org::yakindu::sct::generator::c::templates::Expression»
«EXTENSION org::yakindu::sct::generator::c::templates::Naming»


«DEFINE file FOR ExecutionFlow»

«FILE 'main.c'»
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include "Timer.h"
#include "DummyTimer.h"
#include "«StName()».h"
#include "«EvName()».h"

#define MAXEVENTSPERTYPE 4
int main()
{
	const char* stateName[6] = {"State1", "State2", "State3", "State4", "State5", "State6"};

	«StName()» machine;
	Timer dummyTimer;
	EventPool eventPool;
    _Event* ev;
    Event2* e2;

	/* set up dummy Timer */
	dummyTimer_init(&dummyTimer);

	/* Set up Event Pool */
	eventPool_init_heap(&eventPool, event_last, MAXEVENTSPERTYPE);

	/* initialize state machine */
	«stName()»_init(&machine, &dummyTimer, &eventPool);

	/* check the state */
	printf("%s\n", stateName[statemachineBase_getState((StatemachineBase*)&machine, 0)]);
	assert( strcmp(stateName[statemachineBase_getState((StatemachineBase*)&machine, 0)], "State1") == 0);

	/* create one event */
	
	ev = eventPool_createEvent(&eventPool, ev_event1);

	// The following would work as well
	// This can be used, if you want to set some information within Event1
	// e1 = ((Event1*)(eventPool_createEvent(&eventPool, ev_event1)));

	/* set the event */
	«stName()»_setEvent(&machine, ev);

	/* run the cycle */
	«stName()»_runCycle(&machine);

	/* check the state */
	printf("%s\n", stateName[statemachineBase_getState((StatemachineBase*)&machine, 0)]);
	assert( strcmp(stateName[statemachineBase_getState((StatemachineBase*)&machine, 0)], "State3") == 0);


	e2 = ((Event2*)(eventPool_createEvent(&eventPool, ev_event2)));
	«stName()»_setEvent(&machine, e2);

	«stName()»_runCycle(&machine);

	printf("%s\n", stateName[statemachineBase_getState((StatemachineBase*)&machine, 0)]);
	assert( strcmp(stateName[statemachineBase_getState((StatemachineBase*)&machine, 0)], "State1") == 0);

	/* does event queuing work? */
	ev = eventPool_createEvent(&eventPool, ev_event1);
	«stName()»_setEvent(&machine, ev);

	ev = eventPool_createEvent(&eventPool, ev_event3);
	«stName()»_setEvent(&machine, ev);

	«stName()»_runCycle(&machine);

	printf("%s\n", stateName[statemachineBase_getState((StatemachineBase*)&machine, 0)]);
	assert( strcmp(stateName[statemachineBase_getState((StatemachineBase*)&machine, 0)], "State3") == 0);

	assert( «stName()»_eventWaiting(&machine) == bool_false );


	ev = eventPool_createEvent(&eventPool, ev_event3);
	«stName()»_setEvent(&machine, ev);

	assert( «stName()»_eventWaiting(&machine) == bool_true );

	«stName()»_runCycle(&machine);

	printf("%s\n", stateName[statemachineBase_getState((StatemachineBase*)&machine, 0)]);
	assert( strcmp(stateName[statemachineBase_getState((StatemachineBase*)&machine, 0)], "State4") == 0);


	ev = eventPool_createEvent(&eventPool, ev_event4);
	«stName()»_setEvent(&machine, ev);

	«stName()»_runCycle(&machine);

	printf("%s\n", stateName[statemachineBase_getState((StatemachineBase*)&machine, 0)]);
	assert( strcmp(stateName[statemachineBase_getState((StatemachineBase*)&machine, 0)], "State3") == 0);


	ev = eventPool_createEvent(&eventPool, ev_event3);
	«stName()»_setEvent(&machine, ev);

	«stName()»_runCycle(&machine);

	printf("%s\n", stateName[statemachineBase_getState((StatemachineBase*)&machine, 0)]);
	assert( strcmp(stateName[statemachineBase_getState((StatemachineBase*)&machine, 0)], "State4") == 0);


	ev = eventPool_createEvent(&eventPool, ev_event5);
	«stName()»_setEvent(&machine, ev);

	«stName()»_runCycle(&machine);

	printf("%s\n", stateName[statemachineBase_getState((StatemachineBase*)&machine, 0)]);
	assert( strcmp(stateName[statemachineBase_getState((StatemachineBase*)&machine, 0)], "State1") == 0);

	«stName()»_exit(&machine);
	timer_exit(&dummyTimer);
	eventPool_exit(&eventPool);

	return(0);
}

«ENDFILE»

«ENDDEFINE»