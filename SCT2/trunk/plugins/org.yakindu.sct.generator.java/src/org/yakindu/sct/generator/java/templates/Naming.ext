/*
  Copyright (c) 2011 committers of YAKINDU and others.
  All rights reserved. This program and the accompanying materials
  are made available under the terms of the Eclipse Public License v1.0
  which accompanies this distribution, and is available at
  http://www.eclipse.org/legal/epl-v10.html
  Contributors:
  	committers of YAKINDU - initial API and implementation  
  	
  	@author Joern Seger - Initial contribution and API
  	@author Markus Muehlbrandt - Java adaptions and extensions
 */
import stext;
import sexec;
import ecore;
import sgraph;

List declaredVariables(ExecutionFlow flow) : flow.scopes.declarations.typeSelect(VariableDefinition);

getNamedInterfaceScope(ExecutionFlow this) : scopes.typeSelect(InterfaceScope).select(interfaceScope|interfaceScope.name!=null);
getNamedInterfaceScopeDeclarations(ExecutionFlow this) : getNamedInterfaceScope().declarations;
getNamedInterfaceScopeVariables(ExecutionFlow this) : getNamedInterfaceScopeDeclarations().typeSelect(VariableDefinition);
getNamedInterfaceScopeEvents(ExecutionFlow this) : getNamedInterfaceScopeDeclarations().typeSelect(EventDefinition);
getNamedInterfaceScopeVoidEvents(ExecutionFlow this) : getNamedInterfaceScopeEvents().select(e|e.type==Type::void);
getNamedInterfaceScopeValuedEvents(ExecutionFlow this) : getNamedInterfaceScopeEvents().select(e|e.type!=Type::void);

getUnnamedInterfaceScopeDeclarations(ExecutionFlow this) : 
	scopes.typeSelect(InterfaceScope).select(interfaceScope|interfaceScope.name==null).declarations;
	
getUnnamedInterfaceScopeVariables(ExecutionFlow this) :
	getUnnamedInterfaceScopeDeclarations().typeSelect(VariableDefinition);
	
getUnnamedInterfaceScopeEvents(ExecutionFlow this) :
	getUnnamedInterfaceScopeDeclarations().typeSelect(EventDefinition);
	
getUnnamedInterfaceScopeVoidEvents(ExecutionFlow this) :
	getUnnamedInterfaceScopeEvents().select(e|e.type==Type::void);
	
getUnnamedInterfaceScopeValuedEvents(ExecutionFlow this) :
	getUnnamedInterfaceScopeEvents().select(e|e.type!=Type::void);


getInternalScopeDeclarations(ExecutionFlow this) :
	scopes.typeSelect(InternalScope).declarations;

getInternalScopeVariables(ExecutionFlow this) :
	getInternalScopeDeclarations().typeSelect(VariableDefinition);

getInternalScopeEvents(ExecutionFlow this) :
	getInternalScopeDeclarations().typeSelect(EventDefinition);
	
getInternalScopeVoidEvents(ExecutionFlow this) :
	getInternalScopeEvents().select(e|e.type==Type::void);
	
getInternalScopeValuedEvents(ExecutionFlow this) :
	getInternalScopeEvents().select(e|e.type!=Type::void);

getTimeEvents(ExecutionFlow this) : scopes.typeSelect(Scope).declarations.typeSelect(TimeEvent);

String getStatemachineName(ExecutionFlow this) : name.toFirstUpper();
String getAbstractStatemachineName(ExecutionFlow this) : name.toFirstUpper() + "AbstractBaseStatemachine";
String getEventBasedStatemachineName(ExecutionFlow this) : name.toFirstUpper() + "EventBasedStatemachine";
String getCycleBasedStatemachineName(ExecutionFlow this) : name.toFirstUpper() + "CyleBasedStatemachine";

String getInterfaceName(InterfaceScope this) :  "Interface" + name.toFirstUpper(); 
String getAbstractInterfaceName(InterfaceScope this) :  "Abstract" + getInterfaceName();

String getQualifiedName(EventDefinition this) : ((InterfaceScope)eContainer).name.toFirstUpper()+name.toFirstUpper();
String getValueName(EventDefinition this) : "eventValue"+name.toFirstUpper();
String getInternalName(EventDefinition this) : name.toFirstUpper();

String getValueName(VariableDefinition this) : "var"+name.toFirstUpper();

getName(ExecutionState this) :
	simpleName.replaceAll(" ","").toFirstUpper();

getName(Event this) :
	getContext() + name.toFirstUpper();

getName(TimeEvent this) :
	name.replaceAll(" ","").toFirstUpper();

String getterVisibility(EventDefinition this) : 
	switch (direction) {
	case (Direction::OUT) : "public"
	case (Direction::IN) : "private"
	default : "private"
	};
	
String setterVisibility(EventDefinition this) : 
	switch (direction) {
	case (Direction::OUT) : "private"
	case (Direction::IN) : "public"
	default : "private"
	};
	
String setterValueVisibility(VariableDefinition this) : 
	if (readonly) then "private"
	else "public";

String getJavaType(Type type) :
		switch (type) {
		case (Type::real) : "float"
		case (Type::integer) : "int"
		case (Type::boolean) : "boolean"
		case (Type::string) : "string"
		default : ""
		};

cached String functionName(Step step) : 
	(step.isEffect()) ? step.actionFunctionName() : (
	(step.isReactionCheck()) ? step.checkFunctionName() : (
	(step.isEntryAction()) ? step.entryActionFunctionName() : ( 
	(step.isExitAction()) ? step.exitActionFunctionName() : 
	" !! unknown function type !!" )));
 
statemachineEntryFunctionName(EnterState this):
	if (this.name != null) then
		"entry"+name.toFirstUpper().replaceAll(" ","")+"()"
	else
		"entry()";

actionFunctionName(Step this) : "actions" + getName(reaction().state()) + this.reaction().name.toFirstUpper(); 
checkFunctionName(Step this) : "condition" + getName(reaction().state()) + this.reaction().name.toFirstUpper(); 
entryActionFunctionName(Step this) : "entryActions" + getName(state()); 
exitActionFunctionName(Step this) : "exitActions" + getName(state()); 

isEffect(Step step) : (! Check.isInstance(step)) && Reaction.isInstance(step.eContainer) ;
isReactionCheck(Step step) : Reaction.isInstance(step.eContainer) && Check.isInstance(step);
isEntryAction(Step step) : ExecutionState.isInstance(step.eContainer) && step.state().entryAction == step;
isExitAction(Step step) : ExecutionState.isInstance(step.eContainer) && step.state().exitAction == step;

Reaction reaction(Step this) : (Reaction) this.eContainer ;
ExecutionState state(Reaction this) : (ExecutionState) eContainer;
ExecutionState state(Step this) : (ExecutionState) eContainer;

String getContext(Variable this) : 
	if (InterfaceScope.isInstance(eContainer) && ((InterfaceScope)eContainer).name != null) then  
		"getAbstractInterface"+((InterfaceScope)eContainer).name.toFirstUpper()+"()."
	
	else 
		"";
		
getContext(Event this) : 
	if (InterfaceScope.isInstance(eContainer) && ((InterfaceScope)eContainer).name != null) then  
		((InterfaceScope)eContainer).name.toFirstUpper()
	else 
		"";
		
getLicenseHeader() : "/**
 * Copyright (c) 2011 committers of YAKINDU and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * Contributors:
 * 	committers of YAKINDU - initial API and implementation
 * 
 */";
