grammar org.yakindu.sct.model.stext.SText with org.yakindu.base.expressions.Expressions

generate stext "http://www.yakindu.org/sct/statechart/SText"
import "http://www.yakindu.org/sct/sgraph/2.0.0" as sgraph
import "http://www.yakindu.org/base/types/2.0.0" as types
import "http://www.yakindu.org/base/base/2.0.0" as base
import "http://www.yakindu.org/base/expressions/Expressions" as exp
/* ---- root rules ----
These root rules are not relevant for the grammar integration in the statechart. They just integrate the different start rules consistently 
into a single grammar. 
*/
Root:
	(roots+=DefRoot)*;

DefRoot:
	StatechartRoot | StateRoot | TransitionRoot;

StatechartRoot:
	'@@statechart@@' def=StatechartSpecification;

StateRoot:
	'@@state@@' def=StateSpecification;

TransitionRoot:
	'@@transition@@' def=TransitionSpecification;
/* ---- start rules ----
Define the starting points used by the statechart integration. These rules hook in the concrete rules of the specific grammar.
*/
ScopedElement returns sgraph::ScopedElement:
	StatechartSpecification;

StatechartSpecification:
	{StatechartSpecification} ('namespace' namespace=FQN)? 
	(imports+=Import)*
	(scopes+=StatechartScope)*;

StateSpecification:
	scope=StateScope;

TransitionSpecification:
	reaction=TransitionReaction;
/* ---- scope rules ----
Defines different kinds of scopes that contain element definitions. Scopes are used for element definitions in statechart, regions, and state 
*/
Scope returns sgraph::Scope:
	(StateScope | StatechartScope); // a SimpleScope is used for states and regions
 StateScope returns sgraph::Scope:
	{SimpleScope} (declarations+=(LocalReaction /* | Entrypoint | Exitpoint */))*;
// defines the poosible scopes for statecharts
 StatechartScope:
	InterfaceScope | InternalScope;

NamedInterfaceScope returns base::NamedElement:
	InterfaceScope;

InterfaceScope:
	{InterfaceScope} 'interface' (name=XID)? ':' (declarations+=(EventDeclarartion | VariableDeclaration |
	OperationDeclaration //		| Entrypoint 
 //		| Exitpoint
))*;

InternalScope:
	{InternalScope} 'internal' ':' (declarations+=(EventDeclarartion | VariableDeclaration | OperationDeclaration |
	LocalReaction))*; /* ---- declarations ----
a definition is a top level element of a definition scope. */ 

Import returns sgraph::Import:
	'import' importedNamespace=QIDWithWildcards';'
;

QIDWithWildcards:
	QID ('.*')?;
	
QID:
	ID ('.' ID)*;


Declaration returns sgraph::Declaration:
	EventDeclarartion | VariableDeclaration | OperationDeclaration | LocalReaction //		| Entrypoint 
 //		| Exitpoint
;

/* ---- event definition ---- */ EventDeclarartion returns sgraph::Event:
	EventDefinition;

EventFeature returns types::Event:
	EventDefinition;

EventDefinition:
	(direction=Direction)? 'event' name=XID (':' type=[types::Type|FQN])?; // (derivation=EventDerivation)?;

//EventDerivation:
 //	 (':' value=Expression)?;
 enum Direction:
	LOCAL='local' | IN='in' | OUT='out'; /* ---- variable definition ---- */ VariableDeclaration returns
sgraph::Variable:
	VariableDefinition;

VariableFeature returns types::Property:
	VariableDefinition;

VariableDefinition:
	{VariableDefinition} 'var' ((readonly?='readonly')? & (external?='external')?) name=XID ':' type=[types::Type|FQN]
	('=' initialValue=Expression)?; /* ---- operation definition ---- */ OperationDeclaration returns
sgraph::Declaration:
	OperationDefinition;

OperationFeature returns types::Operation:
	OperationDefinition;

OperationDefinition:
	{OperationDefinition} 'operation' name=XID '(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')' (':'
	type=[types::Type|FQN])?;

Parameter returns types::Parameter:
	name=XID ':' type=[types::Type|FQN]; /* ---- entrypoint definition ---- */ //Entrypoint returns sgraph::Declaration:

//	{Entrypoint} 'entrypoint' name=XID;
 /* ---- exitpoint definition ---- */ //Exitpoint returns sgraph::Declaration:

//	{Exitpoint} 'exitpoint' name=XID;
 /* ---- Datatype rules ---- */ XID:
	ID | 'namespace' | 'interface' | 'internal' | 'event' | 'local' | 'in' | 'out' | 'var' | 'readonly' | 'external' |
	'operation' | 'default' | 'else' | 'entry' | 'exit' | 'always' | 'oncycle' | 'raise' | 'valueof' | 'active';

FQN:
	XID ('.' XID)*;
/* ---- reaction rules ----
Define the structure of reactions that are central for describing the statecharts behavior. 
*/
Reaction returns sgraph::Reaction:
	LocalReaction | TransitionReaction;

LocalReaction:
	(trigger=ReactionTrigger) => ('/' effect=ReactionEffect);

TransitionReaction:
	{TransitionReaction} (trigger=StextTrigger)? ('/' effect=ReactionEffect)? ('#' (properties+=TransitionProperty)*)?;

StextTrigger returns sgraph::Trigger:
	ReactionTrigger | DefaultTrigger;

ReactionTrigger returns sgraph::Trigger:
	{ReactionTrigger} ((triggers+=EventSpec ("," triggers+=EventSpec)* (=> '[' guard=Guard ']')?) | ('[' guard=Guard
	']'));

DefaultTrigger returns sgraph::Trigger:
	{DefaultTrigger} ('default' | 'else');

Guard:
	{Guard} expression=Expression;

ReactionEffect returns sgraph::Effect:
	{ReactionEffect} actions+=(Expression | EventRaisingExpression) (=> ';' actions+=(Expression |
	EventRaisingExpression))*;

TransitionProperty returns sgraph::ReactionProperty:
	EntryPointSpec | ExitPointSpec;

EntryPointSpec:
	'>' entrypoint=ID;

ExitPointSpec:
	exitpoint=ID '>';

EventSpec:
	RegularEventSpec | TimeEventSpec | BuiltinEventSpec;

RegularEventSpec:
	event=FeatureCall; // TODO: redefine after trigger - we need to use it with clocks
 TimeEventSpec:
	type=TimeEventType value=ConditionalExpression unit=TimeUnit;

enum TimeEventType:
	after | every;

BuiltinEventSpec:
	EntryEvent | ExitEvent | AlwaysEvent;

EntryEvent:
	{EntryEvent} 'entry';

ExitEvent:
	{ExitEvent} 'exit';

AlwaysEvent:
	{AlwaysEvent} ('always' | 'oncycle'); //****************
 // Statechart specific expressions
 //****************

EventRaisingExpression returns exp::Expression:
	{EventRaisingExpression} 'raise' event=FeatureCall (':' value=Expression)?;

EventValueReferenceExpression returns exp::Expression:
	{EventValueReferenceExpression} 'valueof' '(' value=FeatureCall ')';

ActiveStateReferenceExpression returns exp::Expression:
	{ActiveStateReferenceExpression} 'active' '(' value=[sgraph::State|FQN] ')';

PrimaryExpression returns exp::Expression:
	PrimitiveValueExpression | FeatureCall | ActiveStateReferenceExpression | EventValueReferenceExpression |
	ParenthesizedExpression;

enum TimeUnit:
	second='s' | millisecond='ms' | microsecond='us' | nanosecond='ns';
