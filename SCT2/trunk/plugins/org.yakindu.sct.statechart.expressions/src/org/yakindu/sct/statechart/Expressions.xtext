grammar org.yakindu.sct.statechart.Expressions with org.eclipse.xtext.common.Terminals

generate expressions "http://www.yakindu.org/sct/statechart/Expressions"
import "platform:/resource/org.yakindu.sct.model.statechart/model/emf/statechart.ecore" as sct

EntryRule:
	entry=(StateExpression | CustomTransitionExpression | ElementDefinition);

//****************
// State Expression
//****************
StateExpression:
	{StateExpression} (entryExpression+=EntryExpression)* (exitExpression+=ExitExpression)*
	(ontickExpression+=OnTickExpression)*;

EntryExpression:
	'entry:' expression=ExpressionRule;

ExitExpression:
	'exit:' expression=ExpressionRule;

OnTickExpression:
	'do:' expression=ExpressionRule;

//****************
// Transition Expression
//****************
CustomTransitionExpression:
	{CustomTransitionExpression}
	(triggers+=[sct::Event] ("," triggers+=[sct::Event])*)
	('[' guardExpression=LogicalOrExpression ']')?
	('/' action=ExpressionRule)?;


//****************
// Statechart Expression
//****************
ElementDefinition:
	{ElementDefinition} (definitionScopes+=DefinitionScope)*;
	
DefinitionScope: InterfaceScope | InternalScope;

InterfaceScope: {InterfaceScope} 'interface' (name=ID)? ':' (definitions+=Definition)*;

InternalScope:  {InternalScope} 'internal' ':' (definitions+=Definition)*;

Definition: VariableDefinition | EventDefinition | Operation | Entrypoint | Exitpoint | Clock | CustomTransitionExpression ;


VariableDefinition:
	 'var' ((readonly?='readonly')? & (external?='external')?) name=ID ':' type=Type ('=' value=Literal)?;

//VariableModifier: (readonly?='readonly')? & (external?='external')?;

EventDefinition:
	(direction=Direction)? 'event' name=ID (':' type=Type)? (derivation=EventDerivation)?;
	
EventDerivation:
	'=' condition=ExpressionRule (':' value=ExpressionRule)?; 
	
enum Direction: IN='in' | OUT='out';


Operation: 'operation' name=ID '(' (paramTypes+=Type (',' paramTypes+= Type)*)?')' (':' type=Type)? ;
	
Entrypoint: 'entrypoint' name=ID;

Exitpoint: 'exitpoint' name=ID;

Clock: 'clock' name=ID;

//****************
// Expression Grammar
//****************
ExpressionRule:
	expression=(LogicalOrExpression | RaiseEventExpression);

RaiseEventExpression:
	'raise' event=[sct::Event];

LogicalOrExpression returns Expression:
	LogicalAndExpression ({LogicalOrExpression.leftOperand=current} '||'
	rightOperand=LogicalAndExpression)*;

LogicalAndExpression returns Expression:
	LogicalNotExpression ({LogicalAndExpression.leftOperand=current}
	'&&' rightOperand=LogicalNotExpression)*;

LogicalNotExpression returns Expression:
	LogicalRelationExpression | {LogicalNotExpression} '!'
	operand=LogicalRelationExpression;

LogicalRelationExpression returns Expression:
	NumericalAddSubtractExpression
	({LogicalRelationExpression.leftOperand=current} operator=RelationalOperator
	rightOperand=NumericalAddSubtractExpression)*;

NumericalAddSubtractExpression returns Expression:
	NumericalMultiplyDivideExpression
	({NumericalAddSubtractExpression.leftOperand=current}
	operator=AdditiveOperator
	rightOperand=NumericalMultiplyDivideExpression)*;

NumericalMultiplyDivideExpression returns Expression:
	NumericalUnaryExpression
	({NumericalMultiplyDivideExpression.leftOperand=current}
	operator=MultiplicativeOperator
	rightOperand=NumericalUnaryExpression)*;

NumericalUnaryExpression returns Expression:
	PrimaryExpression | {NumericalUnaryExpression}
	operator=UnaryOperator operand=PrimaryExpression;

PrimaryExpression returns Expression:
	ValueExpression | '(' LogicalOrExpression ')';

enum AdditiveOperator:
	plus='+' | minus='-';

enum MultiplicativeOperator:
	mul='*' | div='/' | mod='%';

enum UnaryOperator:
	positive='+' | negative='-' | complement='~';

enum RelationalOperator:
	smaller='<' | smallerEqual='<=' | greater='>' | greaterEqual='>=' |
	equals='==' | notEquals='!=';

enum DirectionKind:
	incoming='in' | outgoing='out';

enum TimeUnit:
	second='s'
	| millisecond='ms'
	| nanosecond='ns';

enum Type:
	void | integer | real | boolean | string;

ValueExpression returns Expression:
	PrimitiveValueExpression | VariableReferenceExpression;

PrimitiveValueExpression returns Expression:
	{PrimitiveValueExpression} value=Literal;

VariableReferenceExpression returns Expression:
	{PropertyReferenceExpression} value=[sct::Variable];

Literal:
	BOOL | INT | STRING | FLOAT;

terminal BOOL:
	'true' | 'false';

terminal FLOAT:
	('-' | '+')? (INT '.' INT) ('e' ('-' | '+') INT)?;

