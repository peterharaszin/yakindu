/**
 * Copyright (c) 2010 committers of YAKINDU and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     committers of YAKINDU - initial API and implementation
 */
/*
* generated by Xtext
*/
package com.yakindu.statechart.model.expressions.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import com.yakindu.statechart.model.expressions.services.StatechartExpressionsGrammarAccess;

import com.google.inject.Inject;

public class StatechartExpressionsParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private StatechartExpressionsGrammarAccess grammarAccess;
		
	public StatechartExpressionsGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Alternatives(this, this, 0, inst);
			case 1: return new TriggerExpression_Group(this, this, 1, inst);
			case 2: return new GuardExpression_ExpressionAssignment(this, this, 2, inst);
			case 3: return new ActionExpression_StatementAssignment(this, this, 3, inst);
			case 4: return new Trigger_EventAssignment(this, this, 4, inst);
			case 5: return new Event_Alternatives(this, this, 5, inst);
			case 6: return new SignalEvent_IdentifierAssignment(this, this, 6, inst);
			case 7: return new TimeEvent_Group(this, this, 7, inst);
			case 8: return new TimeExpression_Alternatives(this, this, 8, inst);
			case 9: return new VariableReference_Alternatives(this, this, 9, inst);
			case 10: return new Variable_IdentifierAssignment(this, this, 10, inst);
			case 11: return new TimeConstant_Group(this, this, 11, inst);
			case 12: return new Statement_Group(this, this, 12, inst);
			case 13: return new VariableAssignment_Group(this, this, 13, inst);
			case 14: return new ProcedureCall_Group(this, this, 14, inst);
			case 15: return new Procedure_IdentifierAssignment(this, this, 15, inst);
			case 16: return new EventRaising_Group(this, this, 16, inst);
			case 17: return new BooleanOrExpression_Group(this, this, 17, inst);
			case 18: return new BooleanAndExpression_Group(this, this, 18, inst);
			case 19: return new BitwiseXorExpression_Group(this, this, 19, inst);
			case 20: return new BitwiseOrExpression_Group(this, this, 20, inst);
			case 21: return new BitwiseAndExpression_Group(this, this, 21, inst);
			case 22: return new EqualityExpression_Group(this, this, 22, inst);
			case 23: return new RelationalExpression_Group(this, this, 23, inst);
			case 24: return new ConditionalExpression_Group(this, this, 24, inst);
			case 25: return new ShiftExpression_Group(this, this, 25, inst);
			case 26: return new AdditiveExpression_Group(this, this, 26, inst);
			case 27: return new MultiplicativeExpression_Group(this, this, 27, inst);
			case 28: return new UnaryExpression_Group(this, this, 28, inst);
			case 29: return new PrimaryExpression_Alternatives(this, this, 29, inst);
			case 30: return new NestedExpression_ExpressionAssignment(this, this, 30, inst);
			case 31: return new LiteralValue_ValueAssignment(this, this, 31, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Expression ****************
 *
 * Expression:
 *   TriggerExpression|GuardExpression|ActionExpression; 
 * 
 * // specify your DSL grammar rules here ...
 * // IMPORTANT: You should change the property 'overwrite.pluginresources=true' in the properties file to 'overwrite.pluginresources=false' AFTER first generation
 *
 **/

// TriggerExpression|GuardExpression|ActionExpression 
// 
// // specify your DSL grammar rules here ...
// // IMPORTANT: You should change the property 'overwrite.pluginresources=true' in the properties file to 'overwrite.pluginresources=false' AFTER first generation
protected class Expression_Alternatives extends AlternativesToken {

	public Expression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getExpressionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_TriggerExpressionParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Expression_GuardExpressionParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Expression_ActionExpressionParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// TriggerExpression
protected class Expression_TriggerExpressionParserRuleCall_0 extends RuleCallToken {
	
	public Expression_TriggerExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getTriggerExpressionParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TriggerExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TriggerExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTriggerExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// GuardExpression
protected class Expression_GuardExpressionParserRuleCall_1 extends RuleCallToken {
	
	public Expression_GuardExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getGuardExpressionParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GuardExpression_ExpressionAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(GuardExpression_ExpressionAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getGuardExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ActionExpression
protected class Expression_ActionExpressionParserRuleCall_2 extends RuleCallToken {
	
	public Expression_ActionExpressionParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getActionExpressionParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ActionExpression_StatementAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ActionExpression_StatementAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getActionExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Expression ****************/


/************ begin Rule TriggerExpression ****************
 *
 * TriggerExpression:
 *   triggers+=Trigger ("," triggers+=Trigger)*;
 *
 **/

// triggers+=Trigger ("," triggers+=Trigger)*
protected class TriggerExpression_Group extends GroupToken {
	
	public TriggerExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getTriggerExpressionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TriggerExpression_Group_1(parent, this, 0, inst);
			case 1: return new TriggerExpression_TriggersAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTriggerExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// triggers+=Trigger
protected class TriggerExpression_TriggersAssignment_0 extends AssignmentToken  {
	
	public TriggerExpression_TriggersAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTriggerExpressionAccess().getTriggersAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Trigger_EventAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("triggers",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("triggers");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTriggerRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTriggerExpressionAccess().getTriggersTriggerParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("," triggers+=Trigger)*
protected class TriggerExpression_Group_1 extends GroupToken {
	
	public TriggerExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getTriggerExpressionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TriggerExpression_TriggersAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class TriggerExpression_CommaKeyword_1_0 extends KeywordToken  {
	
	public TriggerExpression_CommaKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTriggerExpressionAccess().getCommaKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TriggerExpression_Group_1(parent, this, 0, inst);
			case 1: return new TriggerExpression_TriggersAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// triggers+=Trigger
protected class TriggerExpression_TriggersAssignment_1_1 extends AssignmentToken  {
	
	public TriggerExpression_TriggersAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTriggerExpressionAccess().getTriggersAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Trigger_EventAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("triggers",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("triggers");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTriggerRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTriggerExpressionAccess().getTriggersTriggerParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TriggerExpression_CommaKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule TriggerExpression ****************/


/************ begin Rule GuardExpression ****************
 *
 * GuardExpression:
 *   expression=BooleanOrExpression;
 *
 **/

// expression=BooleanOrExpression
protected class GuardExpression_ExpressionAssignment extends AssignmentToken  {
	
	public GuardExpression_ExpressionAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getGuardExpressionAccess().getExpressionAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanOrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getGuardExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBooleanOrExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getGuardExpressionAccess().getExpressionBooleanOrExpressionParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

/************ end Rule GuardExpression ****************/


/************ begin Rule ActionExpression ****************
 *
 * ActionExpression:
 *   statement+=Statement+;
 *
 **/

// statement+=Statement+
protected class ActionExpression_StatementAssignment extends AssignmentToken  {
	
	public ActionExpression_StatementAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getActionExpressionAccess().getStatementAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Statement_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getActionExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("statement",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("statement");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getStatementRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getActionExpressionAccess().getStatementStatementParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ActionExpression_StatementAssignment(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

/************ end Rule ActionExpression ****************/


/************ begin Rule Trigger ****************
 *
 * Trigger:
 *   event=Event;
 *
 **/

// event=Event
protected class Trigger_EventAssignment extends AssignmentToken  {
	
	public Trigger_EventAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTriggerAccess().getEventAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Event_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTriggerRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("event",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("event");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEventRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTriggerAccess().getEventEventParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

/************ end Rule Trigger ****************/


/************ begin Rule Event ****************
 *
 * Event:
 *   SignalEvent|TimeEvent;
 *
 **/

// SignalEvent|TimeEvent
protected class Event_Alternatives extends AlternativesToken {

	public Event_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getEventAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Event_SignalEventParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Event_TimeEventParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEventRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// SignalEvent
protected class Event_SignalEventParserRuleCall_0 extends RuleCallToken {
	
	public Event_SignalEventParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getEventAccess().getSignalEventParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SignalEvent_IdentifierAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SignalEvent_IdentifierAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSignalEventRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// TimeEvent
protected class Event_TimeEventParserRuleCall_1 extends RuleCallToken {
	
	public Event_TimeEventParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getEventAccess().getTimeEventParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TimeEvent_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TimeEvent_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTimeEventRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Event ****************/


/************ begin Rule SignalEvent ****************
 *
 * SignalEvent:
 *   identifier=ID;
 *
 **/

// identifier=ID
protected class SignalEvent_IdentifierAssignment extends AssignmentToken  {
	
	public SignalEvent_IdentifierAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalEventAccess().getIdentifierAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSignalEventRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("identifier",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("identifier");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalEventAccess().getIdentifierIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule SignalEvent ****************/


/************ begin Rule TimeEvent ****************
 *
 * TimeEvent:
 *   "after" "(" duration=TimeExpression ")";
 *
 **/

// "after" "(" duration=TimeExpression ")"
protected class TimeEvent_Group extends GroupToken {
	
	public TimeEvent_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getTimeEventAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TimeEvent_RightParenthesisKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTimeEventRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "after"
protected class TimeEvent_AfterKeyword_0 extends KeywordToken  {
	
	public TimeEvent_AfterKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTimeEventAccess().getAfterKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "("
protected class TimeEvent_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public TimeEvent_LeftParenthesisKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTimeEventAccess().getLeftParenthesisKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TimeEvent_AfterKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// duration=TimeExpression
protected class TimeEvent_DurationAssignment_2 extends AssignmentToken  {
	
	public TimeEvent_DurationAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTimeEventAccess().getDurationAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TimeExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("duration",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("duration");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTimeExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTimeEventAccess().getDurationTimeExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TimeEvent_LeftParenthesisKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class TimeEvent_RightParenthesisKeyword_3 extends KeywordToken  {
	
	public TimeEvent_RightParenthesisKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTimeEventAccess().getRightParenthesisKeyword_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TimeEvent_DurationAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule TimeEvent ****************/


/************ begin Rule TimeExpression ****************
 *
 * TimeExpression:
 *   TimeConstant|VariableReference;
 *
 **/

// TimeConstant|VariableReference
protected class TimeExpression_Alternatives extends AlternativesToken {

	public TimeExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getTimeExpressionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TimeExpression_TimeConstantParserRuleCall_0(parent, this, 0, inst);
			case 1: return new TimeExpression_VariableReferenceParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTimeExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// TimeConstant
protected class TimeExpression_TimeConstantParserRuleCall_0 extends RuleCallToken {
	
	public TimeExpression_TimeConstantParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTimeExpressionAccess().getTimeConstantParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TimeConstant_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TimeConstant_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTimeConstantRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// VariableReference
protected class TimeExpression_VariableReferenceParserRuleCall_1 extends RuleCallToken {
	
	public TimeExpression_VariableReferenceParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTimeExpressionAccess().getVariableReferenceParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableReference_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VariableReference_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVariableReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule TimeExpression ****************/


/************ begin Rule VariableReference ****************
 *
 * VariableReference:
 *   variable=Variable|"var" "(" variable=Variable ")"; 
 * 
 *  
 *        
 *                // backwards compatibility
 *
 **/

// variable=Variable|"var" "(" variable=Variable ")" 
// 
//  
//        
//                // backwards compatibility
protected class VariableReference_Alternatives extends AlternativesToken {

	public VariableReference_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableReference_VariableAssignment_0(parent, this, 0, inst);
			case 1: return new VariableReference_Group_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVariableReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// variable=Variable
protected class VariableReference_VariableAssignment_0 extends AssignmentToken  {
	
	public VariableReference_VariableAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getVariableAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_IdentifierAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("variable",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("variable");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVariableReferenceAccess().getVariableVariableParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// "var" "(" variable=Variable ")"        
//                // backwards compatibility
protected class VariableReference_Group_1 extends GroupToken {
	
	public VariableReference_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableReference_RightParenthesisKeyword_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "var"
protected class VariableReference_VarKeyword_1_0 extends KeywordToken  {
	
	public VariableReference_VarKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getVarKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "("
protected class VariableReference_LeftParenthesisKeyword_1_1 extends KeywordToken  {
	
	public VariableReference_LeftParenthesisKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getLeftParenthesisKeyword_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableReference_VarKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// variable=Variable
protected class VariableReference_VariableAssignment_1_2 extends AssignmentToken  {
	
	public VariableReference_VariableAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getVariableAssignment_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_IdentifierAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("variable",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("variable");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVariableReferenceAccess().getVariableVariableParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VariableReference_LeftParenthesisKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"     // backwards compatibility
protected class VariableReference_RightParenthesisKeyword_1_3 extends KeywordToken  {
	
	public VariableReference_RightParenthesisKeyword_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getRightParenthesisKeyword_1_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableReference_VariableAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule VariableReference ****************/


/************ begin Rule Variable ****************
 *
 * Variable:
 *   identifier=ID;
 *
 **/

// identifier=ID
protected class Variable_IdentifierAssignment extends AssignmentToken  {
	
	public Variable_IdentifierAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableAccess().getIdentifierAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("identifier",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("identifier");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getVariableAccess().getIdentifierIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule Variable ****************/


/************ begin Rule TimeConstant ****************
 *
 * TimeConstant:
 *   value=INT unit=TimeUnit?;
 *
 **/

// value=INT unit=TimeUnit?
protected class TimeConstant_Group extends GroupToken {
	
	public TimeConstant_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getTimeConstantAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TimeConstant_UnitAssignment_1(parent, this, 0, inst);
			case 1: return new TimeConstant_ValueAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTimeConstantRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// value=INT
protected class TimeConstant_ValueAssignment_0 extends AssignmentToken  {
	
	public TimeConstant_ValueAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTimeConstantAccess().getValueAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTimeConstantAccess().getValueINTTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// unit=TimeUnit?
protected class TimeConstant_UnitAssignment_1 extends AssignmentToken  {
	
	public TimeConstant_UnitAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTimeConstantAccess().getUnitAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TimeConstant_ValueAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("unit",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("unit");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getTimeConstantAccess().getUnitTimeUnitEnumRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule TimeConstant ****************/


/************ begin Rule Statement ****************
 *
 * Statement:
 *   (VariableAssignment|EventRaising|ProcedureCall) ";";
 *
 **/

// (VariableAssignment|EventRaising|ProcedureCall) ";"
protected class Statement_Group extends GroupToken {
	
	public Statement_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getStatementAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Statement_SemicolonKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStatementRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// VariableAssignment|EventRaising|ProcedureCall
protected class Statement_Alternatives_0 extends AlternativesToken {

	public Statement_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getStatementAccess().getAlternatives_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Statement_VariableAssignmentParserRuleCall_0_0(parent, this, 0, inst);
			case 1: return new Statement_EventRaisingParserRuleCall_0_1(parent, this, 1, inst);
			case 2: return new Statement_ProcedureCallParserRuleCall_0_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// VariableAssignment
protected class Statement_VariableAssignmentParserRuleCall_0_0 extends RuleCallToken {
	
	public Statement_VariableAssignmentParserRuleCall_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getStatementAccess().getVariableAssignmentParserRuleCall_0_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableAssignment_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VariableAssignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVariableAssignmentRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// EventRaising
protected class Statement_EventRaisingParserRuleCall_0_1 extends RuleCallToken {
	
	public Statement_EventRaisingParserRuleCall_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getStatementAccess().getEventRaisingParserRuleCall_0_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EventRaising_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EventRaising_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEventRaisingRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ProcedureCall
protected class Statement_ProcedureCallParserRuleCall_0_2 extends RuleCallToken {
	
	public Statement_ProcedureCallParserRuleCall_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getStatementAccess().getProcedureCallParserRuleCall_0_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProcedureCall_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ProcedureCall_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getProcedureCallRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


// ";"
protected class Statement_SemicolonKeyword_1 extends KeywordToken  {
	
	public Statement_SemicolonKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getStatementAccess().getSemicolonKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Statement_Alternatives_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Statement ****************/


/************ begin Rule VariableAssignment ****************
 *
 * VariableAssignment:
 *   variableReference=VariableReference operator=AssignmentOperator value=
 *   ConditionalExpression;
 *
 **/

// variableReference=VariableReference operator=AssignmentOperator value=
// ConditionalExpression
protected class VariableAssignment_Group extends GroupToken {
	
	public VariableAssignment_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVariableAssignmentAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableAssignment_ValueAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVariableAssignmentRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// variableReference=VariableReference
protected class VariableAssignment_VariableReferenceAssignment_0 extends AssignmentToken  {
	
	public VariableAssignment_VariableReferenceAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableAssignmentAccess().getVariableReferenceAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableReference_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("variableReference",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("variableReference");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableReferenceRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVariableAssignmentAccess().getVariableReferenceVariableReferenceParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// operator=AssignmentOperator
protected class VariableAssignment_OperatorAssignment_1 extends AssignmentToken  {
	
	public VariableAssignment_OperatorAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableAssignmentAccess().getOperatorAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableAssignment_VariableReferenceAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getVariableAssignmentAccess().getOperatorAssignmentOperatorEnumRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// value=ConditionalExpression
protected class VariableAssignment_ValueAssignment_2 extends AssignmentToken  {
	
	public VariableAssignment_ValueAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableAssignmentAccess().getValueAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConditionalExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConditionalExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVariableAssignmentAccess().getValueConditionalExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VariableAssignment_OperatorAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule VariableAssignment ****************/


/************ begin Rule ProcedureCall ****************
 *
 * ProcedureCall:
 *   procedure=Procedure "(" ")";
 *
 **/

// procedure=Procedure "(" ")"
protected class ProcedureCall_Group extends GroupToken {
	
	public ProcedureCall_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getProcedureCallAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProcedureCall_RightParenthesisKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getProcedureCallRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// procedure=Procedure
protected class ProcedureCall_ProcedureAssignment_0 extends AssignmentToken  {
	
	public ProcedureCall_ProcedureAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getProcedureCallAccess().getProcedureAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Procedure_IdentifierAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("procedure",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("procedure");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getProcedureRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getProcedureCallAccess().getProcedureProcedureParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// "("
protected class ProcedureCall_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public ProcedureCall_LeftParenthesisKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getProcedureCallAccess().getLeftParenthesisKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProcedureCall_ProcedureAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ")"
protected class ProcedureCall_RightParenthesisKeyword_2 extends KeywordToken  {
	
	public ProcedureCall_RightParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getProcedureCallAccess().getRightParenthesisKeyword_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ProcedureCall_LeftParenthesisKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ProcedureCall ****************/


/************ begin Rule Procedure ****************
 *
 * Procedure:
 *   identifier=ID;
 *
 **/

// identifier=ID
protected class Procedure_IdentifierAssignment extends AssignmentToken  {
	
	public Procedure_IdentifierAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getProcedureAccess().getIdentifierAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getProcedureRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("identifier",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("identifier");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getProcedureAccess().getIdentifierIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule Procedure ****************/


/************ begin Rule EventRaising ****************
 *
 * EventRaising:
 *   "raise" "(" event=SignalEvent ")";
 *
 **/

// "raise" "(" event=SignalEvent ")"
protected class EventRaising_Group extends GroupToken {
	
	public EventRaising_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getEventRaisingAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EventRaising_RightParenthesisKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEventRaisingRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "raise"
protected class EventRaising_RaiseKeyword_0 extends KeywordToken  {
	
	public EventRaising_RaiseKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEventRaisingAccess().getRaiseKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "("
protected class EventRaising_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public EventRaising_LeftParenthesisKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEventRaisingAccess().getLeftParenthesisKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EventRaising_RaiseKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// event=SignalEvent
protected class EventRaising_EventAssignment_2 extends AssignmentToken  {
	
	public EventRaising_EventAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getEventRaisingAccess().getEventAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SignalEvent_IdentifierAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("event",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("event");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalEventRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEventRaisingAccess().getEventSignalEventParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EventRaising_LeftParenthesisKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class EventRaising_RightParenthesisKeyword_3 extends KeywordToken  {
	
	public EventRaising_RightParenthesisKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEventRaisingAccess().getRightParenthesisKeyword_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EventRaising_EventAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule EventRaising ****************/


/************ begin Rule BooleanOrExpression ****************
 *
 * BooleanOrExpression:
 *   operand1=BooleanAndExpression ("||" operand2=BooleanAndExpression)*;
 *
 **/

// operand1=BooleanAndExpression ("||" operand2=BooleanAndExpression)*
protected class BooleanOrExpression_Group extends GroupToken {
	
	public BooleanOrExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBooleanOrExpressionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanOrExpression_Group_1(parent, this, 0, inst);
			case 1: return new BooleanOrExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBooleanOrExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operand1=BooleanAndExpression
protected class BooleanOrExpression_Operand1Assignment_0 extends AssignmentToken  {
	
	public BooleanOrExpression_Operand1Assignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanOrExpressionAccess().getOperand1Assignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanAndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand1",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBooleanAndExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBooleanOrExpressionAccess().getOperand1BooleanAndExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("||" operand2=BooleanAndExpression)*
protected class BooleanOrExpression_Group_1 extends GroupToken {
	
	public BooleanOrExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBooleanOrExpressionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanOrExpression_Operand2Assignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "||"
protected class BooleanOrExpression_VerticalLineVerticalLineKeyword_1_0 extends KeywordToken  {
	
	public BooleanOrExpression_VerticalLineVerticalLineKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBooleanOrExpressionAccess().getVerticalLineVerticalLineKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanOrExpression_Group_1(parent, this, 0, inst);
			case 1: return new BooleanOrExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// operand2=BooleanAndExpression
protected class BooleanOrExpression_Operand2Assignment_1_1 extends AssignmentToken  {
	
	public BooleanOrExpression_Operand2Assignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanOrExpressionAccess().getOperand2Assignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanAndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand2",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBooleanAndExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBooleanOrExpressionAccess().getOperand2BooleanAndExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BooleanOrExpression_VerticalLineVerticalLineKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule BooleanOrExpression ****************/


/************ begin Rule BooleanAndExpression ****************
 *
 * BooleanAndExpression:
 *   operand1=BitwiseXorExpression ("&&" operand2=BitwiseXorExpression)*;
 *
 **/

// operand1=BitwiseXorExpression ("&&" operand2=BitwiseXorExpression)*
protected class BooleanAndExpression_Group extends GroupToken {
	
	public BooleanAndExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBooleanAndExpressionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanAndExpression_Group_1(parent, this, 0, inst);
			case 1: return new BooleanAndExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBooleanAndExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operand1=BitwiseXorExpression
protected class BooleanAndExpression_Operand1Assignment_0 extends AssignmentToken  {
	
	public BooleanAndExpression_Operand1Assignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanAndExpressionAccess().getOperand1Assignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BitwiseXorExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand1",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBitwiseXorExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBooleanAndExpressionAccess().getOperand1BitwiseXorExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("&&" operand2=BitwiseXorExpression)*
protected class BooleanAndExpression_Group_1 extends GroupToken {
	
	public BooleanAndExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBooleanAndExpressionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanAndExpression_Operand2Assignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "&&"
protected class BooleanAndExpression_AmpersandAmpersandKeyword_1_0 extends KeywordToken  {
	
	public BooleanAndExpression_AmpersandAmpersandKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBooleanAndExpressionAccess().getAmpersandAmpersandKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanAndExpression_Group_1(parent, this, 0, inst);
			case 1: return new BooleanAndExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// operand2=BitwiseXorExpression
protected class BooleanAndExpression_Operand2Assignment_1_1 extends AssignmentToken  {
	
	public BooleanAndExpression_Operand2Assignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanAndExpressionAccess().getOperand2Assignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BitwiseXorExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand2",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBitwiseXorExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBooleanAndExpressionAccess().getOperand2BitwiseXorExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BooleanAndExpression_AmpersandAmpersandKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule BooleanAndExpression ****************/


/************ begin Rule BitwiseXorExpression ****************
 *
 * BitwiseXorExpression:
 *   operand1=BitwiseOrExpression ("^" operand2=BitwiseOrExpression)*;
 *
 **/

// operand1=BitwiseOrExpression ("^" operand2=BitwiseOrExpression)*
protected class BitwiseXorExpression_Group extends GroupToken {
	
	public BitwiseXorExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBitwiseXorExpressionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BitwiseXorExpression_Group_1(parent, this, 0, inst);
			case 1: return new BitwiseXorExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBitwiseXorExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operand1=BitwiseOrExpression
protected class BitwiseXorExpression_Operand1Assignment_0 extends AssignmentToken  {
	
	public BitwiseXorExpression_Operand1Assignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBitwiseXorExpressionAccess().getOperand1Assignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BitwiseOrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand1",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBitwiseOrExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBitwiseXorExpressionAccess().getOperand1BitwiseOrExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("^" operand2=BitwiseOrExpression)*
protected class BitwiseXorExpression_Group_1 extends GroupToken {
	
	public BitwiseXorExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBitwiseXorExpressionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BitwiseXorExpression_Operand2Assignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "^"
protected class BitwiseXorExpression_CircumflexAccentKeyword_1_0 extends KeywordToken  {
	
	public BitwiseXorExpression_CircumflexAccentKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBitwiseXorExpressionAccess().getCircumflexAccentKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BitwiseXorExpression_Group_1(parent, this, 0, inst);
			case 1: return new BitwiseXorExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// operand2=BitwiseOrExpression
protected class BitwiseXorExpression_Operand2Assignment_1_1 extends AssignmentToken  {
	
	public BitwiseXorExpression_Operand2Assignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBitwiseXorExpressionAccess().getOperand2Assignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BitwiseOrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand2",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBitwiseOrExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBitwiseXorExpressionAccess().getOperand2BitwiseOrExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BitwiseXorExpression_CircumflexAccentKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule BitwiseXorExpression ****************/


/************ begin Rule BitwiseOrExpression ****************
 *
 * BitwiseOrExpression:
 *   operand1=BitwiseAndExpression ("|" operand2=BitwiseAndExpression)*;
 *
 **/

// operand1=BitwiseAndExpression ("|" operand2=BitwiseAndExpression)*
protected class BitwiseOrExpression_Group extends GroupToken {
	
	public BitwiseOrExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBitwiseOrExpressionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BitwiseOrExpression_Group_1(parent, this, 0, inst);
			case 1: return new BitwiseOrExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBitwiseOrExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operand1=BitwiseAndExpression
protected class BitwiseOrExpression_Operand1Assignment_0 extends AssignmentToken  {
	
	public BitwiseOrExpression_Operand1Assignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBitwiseOrExpressionAccess().getOperand1Assignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BitwiseAndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand1",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBitwiseAndExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBitwiseOrExpressionAccess().getOperand1BitwiseAndExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("|" operand2=BitwiseAndExpression)*
protected class BitwiseOrExpression_Group_1 extends GroupToken {
	
	public BitwiseOrExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBitwiseOrExpressionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BitwiseOrExpression_Operand2Assignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "|"
protected class BitwiseOrExpression_VerticalLineKeyword_1_0 extends KeywordToken  {
	
	public BitwiseOrExpression_VerticalLineKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBitwiseOrExpressionAccess().getVerticalLineKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BitwiseOrExpression_Group_1(parent, this, 0, inst);
			case 1: return new BitwiseOrExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// operand2=BitwiseAndExpression
protected class BitwiseOrExpression_Operand2Assignment_1_1 extends AssignmentToken  {
	
	public BitwiseOrExpression_Operand2Assignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBitwiseOrExpressionAccess().getOperand2Assignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BitwiseAndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand2",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBitwiseAndExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBitwiseOrExpressionAccess().getOperand2BitwiseAndExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BitwiseOrExpression_VerticalLineKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule BitwiseOrExpression ****************/


/************ begin Rule BitwiseAndExpression ****************
 *
 * BitwiseAndExpression:
 *   operand1=EqualityExpression ("&" operand2=EqualityExpression)*;
 *
 **/

// operand1=EqualityExpression ("&" operand2=EqualityExpression)*
protected class BitwiseAndExpression_Group extends GroupToken {
	
	public BitwiseAndExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBitwiseAndExpressionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BitwiseAndExpression_Group_1(parent, this, 0, inst);
			case 1: return new BitwiseAndExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBitwiseAndExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operand1=EqualityExpression
protected class BitwiseAndExpression_Operand1Assignment_0 extends AssignmentToken  {
	
	public BitwiseAndExpression_Operand1Assignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBitwiseAndExpressionAccess().getOperand1Assignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand1",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEqualityExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBitwiseAndExpressionAccess().getOperand1EqualityExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("&" operand2=EqualityExpression)*
protected class BitwiseAndExpression_Group_1 extends GroupToken {
	
	public BitwiseAndExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBitwiseAndExpressionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BitwiseAndExpression_Operand2Assignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "&"
protected class BitwiseAndExpression_AmpersandKeyword_1_0 extends KeywordToken  {
	
	public BitwiseAndExpression_AmpersandKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBitwiseAndExpressionAccess().getAmpersandKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BitwiseAndExpression_Group_1(parent, this, 0, inst);
			case 1: return new BitwiseAndExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// operand2=EqualityExpression
protected class BitwiseAndExpression_Operand2Assignment_1_1 extends AssignmentToken  {
	
	public BitwiseAndExpression_Operand2Assignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBitwiseAndExpressionAccess().getOperand2Assignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand2",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEqualityExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBitwiseAndExpressionAccess().getOperand2EqualityExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BitwiseAndExpression_AmpersandKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule BitwiseAndExpression ****************/


/************ begin Rule EqualityExpression ****************
 *
 * EqualityExpression:
 *   operand1=RelationalExpression (operator=EqualityOperator operand2=
 *   RelationalExpression)*;
 *
 **/

// operand1=RelationalExpression (operator=EqualityOperator operand2=
// RelationalExpression)*
protected class EqualityExpression_Group extends GroupToken {
	
	public EqualityExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_Group_1(parent, this, 0, inst);
			case 1: return new EqualityExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEqualityExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operand1=RelationalExpression
protected class EqualityExpression_Operand1Assignment_0 extends AssignmentToken  {
	
	public EqualityExpression_Operand1Assignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getOperand1Assignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand1",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRelationalExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEqualityExpressionAccess().getOperand1RelationalExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (operator=EqualityOperator operand2=RelationalExpression)*
protected class EqualityExpression_Group_1 extends GroupToken {
	
	public EqualityExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_Operand2Assignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// operator=EqualityOperator
protected class EqualityExpression_OperatorAssignment_1_0 extends AssignmentToken  {
	
	public EqualityExpression_OperatorAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getOperatorAssignment_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_Group_1(parent, this, 0, inst);
			case 1: return new EqualityExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getEqualityExpressionAccess().getOperatorEqualityOperatorEnumRuleCall_1_0_0();
			return obj;
		}
		return null;
	}

}

// operand2=RelationalExpression
protected class EqualityExpression_Operand2Assignment_1_1 extends AssignmentToken  {
	
	public EqualityExpression_Operand2Assignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getOperand2Assignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand2",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRelationalExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEqualityExpressionAccess().getOperand2RelationalExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EqualityExpression_OperatorAssignment_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule EqualityExpression ****************/


/************ begin Rule RelationalExpression ****************
 *
 * RelationalExpression:
 *   operand1=ShiftExpression (operator=RelationalOperator operand2=ShiftExpression)*;
 *
 **/

// operand1=ShiftExpression (operator=RelationalOperator operand2=ShiftExpression)*
protected class RelationalExpression_Group extends GroupToken {
	
	public RelationalExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group_1(parent, this, 0, inst);
			case 1: return new RelationalExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRelationalExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operand1=ShiftExpression
protected class RelationalExpression_Operand1Assignment_0 extends AssignmentToken  {
	
	public RelationalExpression_Operand1Assignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getOperand1Assignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ShiftExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand1",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getShiftExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRelationalExpressionAccess().getOperand1ShiftExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (operator=RelationalOperator operand2=ShiftExpression)*
protected class RelationalExpression_Group_1 extends GroupToken {
	
	public RelationalExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Operand2Assignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// operator=RelationalOperator
protected class RelationalExpression_OperatorAssignment_1_0 extends AssignmentToken  {
	
	public RelationalExpression_OperatorAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getOperatorAssignment_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group_1(parent, this, 0, inst);
			case 1: return new RelationalExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getRelationalExpressionAccess().getOperatorRelationalOperatorEnumRuleCall_1_0_0();
			return obj;
		}
		return null;
	}

}

// operand2=ShiftExpression
protected class RelationalExpression_Operand2Assignment_1_1 extends AssignmentToken  {
	
	public RelationalExpression_Operand2Assignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getOperand2Assignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ShiftExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand2",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getShiftExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRelationalExpressionAccess().getOperand2ShiftExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RelationalExpression_OperatorAssignment_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule RelationalExpression ****************/


/************ begin Rule ConditionalExpression ****************
 *
 * ConditionalExpression:
 *   operand1=BooleanOrExpression ("?" operand2=ShiftExpression ":" operand3=
 *   ShiftExpression)?;
 *
 **/

// operand1=BooleanOrExpression ("?" operand2=ShiftExpression ":" operand3=
// ShiftExpression)?
protected class ConditionalExpression_Group extends GroupToken {
	
	public ConditionalExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getConditionalExpressionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConditionalExpression_Group_1(parent, this, 0, inst);
			case 1: return new ConditionalExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConditionalExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operand1=BooleanOrExpression
protected class ConditionalExpression_Operand1Assignment_0 extends AssignmentToken  {
	
	public ConditionalExpression_Operand1Assignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getConditionalExpressionAccess().getOperand1Assignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanOrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand1",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBooleanOrExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConditionalExpressionAccess().getOperand1BooleanOrExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("?" operand2=ShiftExpression ":" operand3=ShiftExpression)?
protected class ConditionalExpression_Group_1 extends GroupToken {
	
	public ConditionalExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getConditionalExpressionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConditionalExpression_Operand3Assignment_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "?"
protected class ConditionalExpression_QuestionMarkKeyword_1_0 extends KeywordToken  {
	
	public ConditionalExpression_QuestionMarkKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getConditionalExpressionAccess().getQuestionMarkKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConditionalExpression_Operand1Assignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// operand2=ShiftExpression
protected class ConditionalExpression_Operand2Assignment_1_1 extends AssignmentToken  {
	
	public ConditionalExpression_Operand2Assignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getConditionalExpressionAccess().getOperand2Assignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ShiftExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand2",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getShiftExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConditionalExpressionAccess().getOperand2ShiftExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConditionalExpression_QuestionMarkKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ":"
protected class ConditionalExpression_ColonKeyword_1_2 extends KeywordToken  {
	
	public ConditionalExpression_ColonKeyword_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getConditionalExpressionAccess().getColonKeyword_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConditionalExpression_Operand2Assignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// operand3=ShiftExpression
protected class ConditionalExpression_Operand3Assignment_1_3 extends AssignmentToken  {
	
	public ConditionalExpression_Operand3Assignment_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getConditionalExpressionAccess().getOperand3Assignment_1_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ShiftExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand3",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand3");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getShiftExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConditionalExpressionAccess().getOperand3ShiftExpressionParserRuleCall_1_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConditionalExpression_ColonKeyword_1_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule ConditionalExpression ****************/


/************ begin Rule ShiftExpression ****************
 *
 * ShiftExpression:
 *   operand1=AdditiveExpression (operator=ShiftOperator operand2=AdditiveExpression)*;
 *
 **/

// operand1=AdditiveExpression (operator=ShiftOperator operand2=AdditiveExpression)*
protected class ShiftExpression_Group extends GroupToken {
	
	public ShiftExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getShiftExpressionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ShiftExpression_Group_1(parent, this, 0, inst);
			case 1: return new ShiftExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getShiftExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operand1=AdditiveExpression
protected class ShiftExpression_Operand1Assignment_0 extends AssignmentToken  {
	
	public ShiftExpression_Operand1Assignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getShiftExpressionAccess().getOperand1Assignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand1",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getShiftExpressionAccess().getOperand1AdditiveExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (operator=ShiftOperator operand2=AdditiveExpression)*
protected class ShiftExpression_Group_1 extends GroupToken {
	
	public ShiftExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getShiftExpressionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ShiftExpression_Operand2Assignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// operator=ShiftOperator
protected class ShiftExpression_OperatorAssignment_1_0 extends AssignmentToken  {
	
	public ShiftExpression_OperatorAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getShiftExpressionAccess().getOperatorAssignment_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ShiftExpression_Group_1(parent, this, 0, inst);
			case 1: return new ShiftExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getShiftExpressionAccess().getOperatorShiftOperatorEnumRuleCall_1_0_0();
			return obj;
		}
		return null;
	}

}

// operand2=AdditiveExpression
protected class ShiftExpression_Operand2Assignment_1_1 extends AssignmentToken  {
	
	public ShiftExpression_Operand2Assignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getShiftExpressionAccess().getOperand2Assignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand2",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getShiftExpressionAccess().getOperand2AdditiveExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ShiftExpression_OperatorAssignment_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule ShiftExpression ****************/


/************ begin Rule AdditiveExpression ****************
 *
 * AdditiveExpression:
 *   operand1=MultiplicativeExpression (operator=AdditiveOperator operand2=
 *   MultiplicativeExpression)*;
 *
 **/

// operand1=MultiplicativeExpression (operator=AdditiveOperator operand2=
// MultiplicativeExpression)*
protected class AdditiveExpression_Group extends GroupToken {
	
	public AdditiveExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group_1(parent, this, 0, inst);
			case 1: return new AdditiveExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operand1=MultiplicativeExpression
protected class AdditiveExpression_Operand1Assignment_0 extends AssignmentToken  {
	
	public AdditiveExpression_Operand1Assignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getOperand1Assignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand1",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMultiplicativeExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAdditiveExpressionAccess().getOperand1MultiplicativeExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (operator=AdditiveOperator operand2=MultiplicativeExpression)*
protected class AdditiveExpression_Group_1 extends GroupToken {
	
	public AdditiveExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Operand2Assignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// operator=AdditiveOperator
protected class AdditiveExpression_OperatorAssignment_1_0 extends AssignmentToken  {
	
	public AdditiveExpression_OperatorAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getOperatorAssignment_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group_1(parent, this, 0, inst);
			case 1: return new AdditiveExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getAdditiveExpressionAccess().getOperatorAdditiveOperatorEnumRuleCall_1_0_0();
			return obj;
		}
		return null;
	}

}

// operand2=MultiplicativeExpression
protected class AdditiveExpression_Operand2Assignment_1_1 extends AssignmentToken  {
	
	public AdditiveExpression_Operand2Assignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getOperand2Assignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand2",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMultiplicativeExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAdditiveExpressionAccess().getOperand2MultiplicativeExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AdditiveExpression_OperatorAssignment_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AdditiveExpression ****************/


/************ begin Rule MultiplicativeExpression ****************
 *
 * MultiplicativeExpression:
 *   operand1=UnaryExpression (operator=MultiplicativeOperator operand2=UnaryExpression
 *   )*;
 *
 **/

// operand1=UnaryExpression (operator=MultiplicativeOperator operand2=UnaryExpression
// )*
protected class MultiplicativeExpression_Group extends GroupToken {
	
	public MultiplicativeExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Group_1(parent, this, 0, inst);
			case 1: return new MultiplicativeExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMultiplicativeExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operand1=UnaryExpression
protected class MultiplicativeExpression_Operand1Assignment_0 extends AssignmentToken  {
	
	public MultiplicativeExpression_Operand1Assignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getOperand1Assignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand1",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand1");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMultiplicativeExpressionAccess().getOperand1UnaryExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (operator=MultiplicativeOperator operand2=UnaryExpression)*
protected class MultiplicativeExpression_Group_1 extends GroupToken {
	
	public MultiplicativeExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Operand2Assignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// operator=MultiplicativeOperator
protected class MultiplicativeExpression_OperatorAssignment_1_0 extends AssignmentToken  {
	
	public MultiplicativeExpression_OperatorAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getOperatorAssignment_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Group_1(parent, this, 0, inst);
			case 1: return new MultiplicativeExpression_Operand1Assignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getMultiplicativeExpressionAccess().getOperatorMultiplicativeOperatorEnumRuleCall_1_0_0();
			return obj;
		}
		return null;
	}

}

// operand2=UnaryExpression
protected class MultiplicativeExpression_Operand2Assignment_1_1 extends AssignmentToken  {
	
	public MultiplicativeExpression_Operand2Assignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getOperand2Assignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand2",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMultiplicativeExpressionAccess().getOperand2UnaryExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new MultiplicativeExpression_OperatorAssignment_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule MultiplicativeExpression ****************/


/************ begin Rule UnaryExpression ****************
 *
 * UnaryExpression:
 *   operator=UnaryOperator? operand=PrimaryExpression;
 *
 **/

// operator=UnaryOperator? operand=PrimaryExpression
protected class UnaryExpression_Group extends GroupToken {
	
	public UnaryExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_OperandAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operator=UnaryOperator?
protected class UnaryExpression_OperatorAssignment_0 extends AssignmentToken  {
	
	public UnaryExpression_OperatorAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getOperatorAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getUnaryExpressionAccess().getOperatorUnaryOperatorEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// operand=PrimaryExpression
protected class UnaryExpression_OperandAssignment_1 extends AssignmentToken  {
	
	public UnaryExpression_OperandAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getOperandAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operand",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operand");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUnaryExpressionAccess().getOperandPrimaryExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UnaryExpression_OperatorAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}


/************ end Rule UnaryExpression ****************/


/************ begin Rule PrimaryExpression ****************
 *
 * PrimaryExpression:
 *   VariableReference|LiteralValue|"(" NestedExpression ")";
 *
 **/

// VariableReference|LiteralValue|"(" NestedExpression ")"
protected class PrimaryExpression_Alternatives extends AlternativesToken {

	public PrimaryExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_VariableReferenceParserRuleCall_0(parent, this, 0, inst);
			case 1: return new PrimaryExpression_LiteralValueParserRuleCall_1(parent, this, 1, inst);
			case 2: return new PrimaryExpression_Group_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// VariableReference
protected class PrimaryExpression_VariableReferenceParserRuleCall_0 extends RuleCallToken {
	
	public PrimaryExpression_VariableReferenceParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getVariableReferenceParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableReference_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VariableReference_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVariableReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// LiteralValue
protected class PrimaryExpression_LiteralValueParserRuleCall_1 extends RuleCallToken {
	
	public PrimaryExpression_LiteralValueParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getLiteralValueParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LiteralValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(LiteralValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getLiteralValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// "(" NestedExpression ")"
protected class PrimaryExpression_Group_2 extends GroupToken {
	
	public PrimaryExpression_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getGroup_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_RightParenthesisKeyword_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class PrimaryExpression_LeftParenthesisKeyword_2_0 extends KeywordToken  {
	
	public PrimaryExpression_LeftParenthesisKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getLeftParenthesisKeyword_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// NestedExpression
protected class PrimaryExpression_NestedExpressionParserRuleCall_2_1 extends RuleCallToken {
	
	public PrimaryExpression_NestedExpressionParserRuleCall_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getNestedExpressionParserRuleCall_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NestedExpression_ExpressionAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NestedExpression_ExpressionAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNestedExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_LeftParenthesisKeyword_2_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class PrimaryExpression_RightParenthesisKeyword_2_2 extends KeywordToken  {
	
	public PrimaryExpression_RightParenthesisKeyword_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getRightParenthesisKeyword_2_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_NestedExpressionParserRuleCall_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule PrimaryExpression ****************/


/************ begin Rule NestedExpression ****************
 *
 * NestedExpression:
 *   expression=ConditionalExpression;
 *
 **/

// expression=ConditionalExpression
protected class NestedExpression_ExpressionAssignment extends AssignmentToken  {
	
	public NestedExpression_ExpressionAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNestedExpressionAccess().getExpressionAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConditionalExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNestedExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConditionalExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNestedExpressionAccess().getExpressionConditionalExpressionParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

/************ end Rule NestedExpression ****************/


/************ begin Rule LiteralValue ****************
 *
 * LiteralValue:
 *   value=Literal;
 *
 **/

// value=Literal
protected class LiteralValue_ValueAssignment extends AssignmentToken  {
	
	public LiteralValue_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getLiteralValueAccess().getValueAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLiteralValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getLiteralValueAccess().getValueLiteralParserRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule LiteralValue ****************/


}
