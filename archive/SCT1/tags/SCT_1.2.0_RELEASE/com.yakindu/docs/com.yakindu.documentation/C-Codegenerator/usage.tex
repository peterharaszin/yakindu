%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright (c) 2009 committers of YAKINDU and others.
% All rights reserved. This program and the accompanying materials
% are made available under the terms of the Eclipse Public License v1.0
% which accompanies this distribution, and is available at
% http://www.eclipse.org/legal/epl-v10.html
%
% Contributors:
%     committers of YAKINDU - initial API and implementation

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Usage}

This section gives a detailed view of how the source code created by the state
machine source code generator can be integrated into an existing C-project.

\subsection{Naming Conventions}

The base name for all handles and function names is the \textit{state chart
name}. E.g. if you state chart diagram is called ''Statechart1'', your state
machine handle is called \texttt{SM\_Statechart1\_Handle} and your function
always begins with \texttt{statechart1\_}. Please notice, that function names
starts with a lower case letter and handle type names start with an upper case
letter.

The global header, that has to be included in this case is
\texttt{statechart1.h}.

\subsection{Calling the state machine}

The state machine itself is designed to be called continuously (e.g. within a 10
ms cycle task) or on event appearance. When the state machine is called without
any events set, the state machine only runs the do actions specified with every
active state.

The usual code for running the state machine called \texttt{Statemachine1} is:

\begin{verbatim}
TASK(mynewTask)
{
  /* Create a state machine handle */
  SM_statemachine1_Handle      sMachine;

  /* Pointer for the state machine communication interface */
  Statemachine1_IfaceHandle*   interfaceHandle=0;

  /* Initialize the handle and return the interface handle */
  statemachine1_init(&sMachine, &interfaceHandle);

  /* Run the task until forever */
  while(1==1) {

    /* Call one cycle of the state machine */
    (void)statemachine1_runcycle(&sMachine);
	
    /* Syspend the task until next cycle */
    WAIT_NEXT_CYCLE();

  }

}
\end{verbatim}

\subsection{Run-To-Completion}

It is often necessary to run a state machine more often than ones, to reach a
stable state. This is relevant because one state machine cycle only handles one
transition at a time. Therefore the state call to
\texttt{statemachine1\_runcycle()} returns a boolean value to indicate, if the
state is stable now. I.e. The state has not been changed since the last cycle
call. To let the state machine run until it has reached a stable state (This is
called Run-To-Completion), you have to call \texttt{statemachine1\_runcycle()} as
long as it returns \texttt{FALSE}:

\begin{verbatim}
[..]
  /* Run the task until forever */
  while(1==1) {

    /* Call one cycle of the state machine until completion */
    while(statemachine1_runcycle(&sMachine) == FALSE);
	
    /* Syspend the task until next cycle */
    WAIT_NEXT_CYCLE();

  }
[..]
\end{verbatim}

Even if the Run-To-Completion mode is the common state machine behaviour, this
approach bears two main drawbacks: First the state machine may be misconfigured
and the inner while loop is run forever, as two states are re-entered
alternatively, e.g. their guards are set to true. The other drawback is that the
'do'-actions are called whenever a state is re-entered, this is often not wanted.
As a recommendation: do not use a do action at all, specially not if you plan to
use Run-To-Completion or event based cycle calls.

\subsection{Event and Variable access}

The events and variables of a state machine can be accessed through the state
machine interface. This interface is generated with the state machine and the
function regarding this interface can be found in \texttt{$<$state chart
name$>$\_Iface.h}. This header is implicitly available through the global header.

There are two types, which carries the variable and the event identifiers:
\texttt{Statemachine1\_TrgType} and \texttt{Statemachine1\_IntVarType}.

The following functions are available for the user:

\begin{itemize}
\item \texttt{statemachine1\_Iface\_raiseTrigger\\(Statemachine1\_IfaceHandle*
handle, Statemachine1\_TrgType type)}

This function is used to raise a trigger, e.g. to start a transition from one
state to another. The state machine interface handle is available in the main
handle ''\texttt{SM\_statemachine1\_Handle}''.

The \texttt{Statemachine1\_TrgType} is generated due to the state charts
\textit{State Chart Interface}. So if there is a trigger in the state chart
\texttt{statemachine1} defined with name \texttt{trigger1}, this trigger could be
raised throught the interface with a call to
\texttt{statemachine1\_iface\_raiseTrigger (\&SM\_statemachine1\_Handle.ihandle,
statemachine1\_trigger1);}
 
\item \texttt{statemachine1\_Iface\_setVariable\\(Statemachine1\_IfaceHandle*
handle, Statemachine1\_IntVarType type, uint32 value)}

This function is used to set a variable value. The variable must be defined with
the state chart in the \textit{State Chart Interface} and is available through
this interface function by referring the variable by a variable enumeration name,
defined within the \texttt{Statemachine1\_IntVarType}.

\item \texttt{statemachine1\_Iface\_getVariable\\(Statemachine1\_IfaceHandle*
handle, Statemachine1\_IntVarType type)}

This function returns the value of the given state machine variable type.

\end{itemize}   

Additionally there are a number of functions, to clean up the variable and
trigger values.

If you want to keep track of which triggers have been consumed within a state
machine cycle, you can compare the trigger list before and after the run. The
triggers that have been used for a transition are reseted after usage. I.e. every
trigger that belongs to a transition, that has been taken is unset after the
cycle. All other triggers are still set. If you want to forget the other
triggers, that have not been consumed within a cycle, you have to call the
function \texttt{statemachine1\_Iface\_cleanInputTriggers
(statemachine1\_IfaceHandle* handle)}. This call resets all triggers, which are
marked as input for the state machine.

\textbf{Limitations in the actual implementation}

Floating point and boolean variables are not supported.

\subsection{Timer Interface}

To let the state machine not be dependent on direct system information
(especially the system time), the time dependencies are placed outside the state
machine. The activation of a timer event must be done by the implementer by
filling the timer service function prototypes
\texttt{statemachine1\_\-timer\-Iface\_\-installTimer()} and
\texttt{statemachine1\_timer\-Iface\_\-reset\-Timer()}.

These functions are defined in the timer interface header
(\texttt{statemachine1\_timer\_Iface.h}) and the implementation must be put into
the \texttt{statemachine1\_timer\_Iface.c}. The c-module is not added to the
SOURCES in \texttt{make.include}. The easiest way to implement the interface
functions actually is, to copy the file \texttt{statemachine1\_timer\_Iface.c} to
your working directory and add the missing code and compile it with the main
makefile. Whenever the state machine is recreated the original file in the
generation path will be overwritten.

An example for creating a timer service can be found in the example traffic light
project.


